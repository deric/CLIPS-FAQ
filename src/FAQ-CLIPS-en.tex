\documentclass[11pt,svgnames]{scrbook}
\usepackage{a4wide}
\usepackage{epsfig}
\usepackage{amsfonts}
% \usepackage[spanish]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern} 
\pagestyle{plain}
%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper, landscape]
\usepackage{amssymb}
\usepackage{cclicenses}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}

\usepackage[a4paper,margin=1.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\rightmark}
\fancyhead[RE]{\leftmark}
\fancyhead[LE,RO]{\thepage}
\addtolength{\headheight}{2.5pt}
\fancyfoot{}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\renewcommand{\chaptermark}[1]{%
\markboth{\chaptername\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}} 
\usepackage{tikz}

 \usepackage[explicit]{titlesec}
\newcommand*\chapterlabel{}
\titleformat{\chapter}
  {\gdef\chapterlabel{}
   \normalfont\sffamily\Large\bfseries\scshape}
  {\gdef\chapterlabel{\thechapter.\ }}{0pt}
  {\begin{tikzpicture}[remember picture,overlay]
    \node[yshift=-3cm] at (current page.north west)
      {\begin{tikzpicture}[remember picture, overlay]
        \draw[fill=Black!25] (0,0) rectangle
          (\paperwidth,3cm);
        \node[anchor=east,xshift=.9\paperwidth,rectangle,
              rounded corners=20pt,inner sep=11pt,
              fill=Black!75]
              {\color{white}\chapterlabel#1};
       \end{tikzpicture}
      };
   \end{tikzpicture}
  }
\titlespacing*{\chapter}{0pt}{50pt}{0pt}

\titleformat{\section}
{\normalfont\sffamily\bfseries}
{\filright\Large\thesection}{0.5em}{
\Large\bfseries#1 \titleline[c]{\titlerule[1mm]}}

\titlespacing*{\section}{0pt}{25pt}{-5pt}

\titleformat{\subsection}
{\normalfont\sffamily\bfseries}
{\filright\large\thesubsection}{0.5em}{\large\bfseries
#1 \titleline[c]{\titlerule[0.3mm]}}

\titlespacing*{\subsection}{0pt}{20pt}{5pt}


\begin{document}


\begin{titlepage}
 \colorlet{mintgreen}{green!60!black!50}

\begin{center}
  \begin{tikzpicture}[overlay]
\definecolor{palegreen}{rgb}{0.53,0.64,0.28}
\definecolor{darkred}{rgb}{0.65,0.2,0.2}
\definecolor{lightblue}{rgb}{0.22,0.57,0.76}
%\pgfdeclareimage[interpolate=true,width=10cm]{FIB}{FIB-Logo}

\draw [ultra thin,color=darkred,fill](-10,0) rectangle (10,1.5);
\draw [ultra thin,color=palegreen,fill] (-9,1.75) rectangle (-9.1,-26.5);
\draw [ultra thin,color=lightblue,fill] (-6,-16.5) rectangle (6,-17.5);
\draw [ultra thin,color=palegreen,fill] (9,-22) rectangle (9.1,-26.5);
\draw [ultra thin,color=darkred,fill] (6,-25) rectangle (9.5,-26);
\draw [ultra thin,color=darkred,fill](-10,-25) rectangle (-3,-26);

    \node [at={(-4.5,0.75  )},color=white]
        {{\fontencoding{OT1}\fontfamily{phv}\Huge Intel.ligència
 Artificial}};
     \node [at={( -6 ,-25.5  )},color=white] {\fontencoding{OT1}\fontfamily{phv}  \large CURS
2009/2010 1Q};

   \node [at={( 0,-7  )}] {\fontencoding{OT1}\fontfamily{phv} \Huge \textbf{CLIPS FAQ}};

    \node [at={( 0,-17  )},color=white] {\fontencoding{OT1}\fontfamily{phv}\begin{large}            
                                                              \end{large}\large Departament de
Llenguatges i Sistemes
Informàtics};
    \node [at={( 7,0.25  )}] {\fontencoding{OT1}\fontfamily{phv} \large Enginyeria en Informàtica};


    \node [at={( 7.4,-25.5  )},color=white] {\large\byncsa };

%\node [at={( 0,-22.5  )}] {\pgfuseimage{FIB}};
   % \nodeshadowed [at={( 0,2  )}] {Manual for Version \pgftypesetversion};


\end{tikzpicture}



 \end{center}

\vfill

 \end{titlepage}


\newpage
\thispagestyle{empty}


\vspace*{5cm}
\begin{flushleft}
This work is licensed under the Creative Commons\\
Attribution-NonCommercial-ShareAlike License.
\byncsa\\
\ \\
To view a copy of this license, visit
{\tt  http://creativecommons.org/licenses/by-nc-sa/2.0/} or
send a letter to:
\ \\ \ \\

Creative Commons, \\
559 Nathan Abbott Way, Stanford, \\
California 94305, \\
USA.
\end{flushleft}

\thispagestyle{empty}
\newpage

\vspace*{3cm}
On development of this document participated:
\bigskip

\begin{tabular}{l}
Javier Biosca Ruíz de Ojeda\\
José Camallonga González\\
Jordi Chacón Chacón\\
Adrià Figuera Puig\\
Martí Fornés Estarellas\\
Daniel Golobart Castellote\\
Marina Grigoreva\\
Borja Jara García\\
Brian Jiménez Gracía\\
Ignacio Llatser Martí\\
Victor Lloveras Díaz\\
Isaac López Amat\\
Víctor Martínez Jurado\\
Lluís Monsalve Carrasquilla\\
Enric Munné Hernández\\
Jorge Muñoz Gama\\
Ivan Navarro González\\
Manuel Parrilla Gutierrez\\
Marcos Pereira Varela\\
Pere Sivecas Gibert\\
Lluís Suñol Juliachs\\
\end{tabular}

\bigskip
For editing the document is responsible Javier Béjar Alonso
(\texttt{bejar@lsi.upc.edu})

\newpage

\pagenumbering{arabic}

\tableofcontents




\chapter{Introduction}

This document is the result of the compilation of documents written
during the development of practice in class of knowledge based systems  
in fall semester of 2007-2008. During fall semester 2009 this document was translated from Catalan to English.

 The aim of this paper was pick up the doubts that are a frequently
encountered during the development of the practice of SBCS and gather tips that can be useful in development.

 This document mainly explains frequent doubts about the environment CLIPS
and its programming language.

\chapter{Protègè}

To find out how Protègè does work use the help of the application, this material focuses on questions related to integration of the output from Protègè to CLIPS.

\section{How to change the number of instancies in Protègè}

En realidad no se trata de cambiar el nombre de las instancias, sino de darle
algo más visual que un número para poder hacer las relaciones.
Si os encontráis en la pestaña de crear instancias, el último botón es una
flecha hacia abajo. Darle y luego, set display slots. Ahí debéis indicar con que
slot queréis referenciar la instancia.

\section{How to export an ontology from Protégé to CLIPS?}

In Protégé, go to File $\rightarrow$ Export to Format $\rightarrow$ CLIPS. Once you finished, it will create two new files with classes and instances of ontology (\texttt{nom.pont} i \texttt{nom.pins}, respectivament).

Then open both files in a text editor and copy its contents to
CLIPS file as follows:
\begin{verbatim}
 copy-paste of nom.pont

(definstances instancies
 copy-paste of nom.pins
)
\end{verbatim}

\section{Why do I get an error when I have instance that inherits from more than one class?}
Protégé allows multiple inheritance in instances, but not CLIPS. CLIPS can only have multiple inheritance in the classes, but not in instances.

The simplest way to simulate this is to have classes that represent this
multiple inheritance and then have the hang of these instances, but is impractical.

La manera més senzilla de simular-ho és tenir classes que representen aquesta
herència múltiple i fer que les instàncies pengin d'elles, però és poc pràctic.

CLIPS allows you to easily recover the bodies that have a value
specific slot, so the easier it is to have a single hierarchy and
include other possible classifications as slots.

El CLIPS et permet recuperar fàcilment les instàncies que tenen un valor
específic en un slot, pel que el més senzill és tenir una única jerarquia i
incloure altres possibles classificacions com a slots.


\chapter{CLIPS}
\section{Installation of CLIPS}

\subsection{How to install CLIPS?}
CLIPS is a cross-platform tool and is available for the three
most used OS: Microsoft Windows, Linux and Mac OS X.

\subsubsection*{How to install CLIPS in Windows?}
First of all we have to download the program from the official website of CLIPS, you can find it here:\break
\href{http://clipsrules.sourceforge.net/}{\texttt{
(http://clipsrules.sourceforge.net/)} }. 

From the download section you can choose version for Windows and intall it into your OS.


\subsubsection*{How to install CLIPS in Linux?}
In many Linux distributions is CLIPS available as an additional Package and you can install version with a graphic interface. The package is usually named \texttt{clips} and the version with graphical environment \texttt{xclips}. 

If you don't find a package for your distribution you can always compile it from sources.

\begin{description}
 \item[Ubuntu] There is currently no package with graphical interface available. You can install command line version as follows:
\begin{verbatim}
	sudo apt-get install clips
\end{verbatim}
\end{description}

Anyway the Windows version of CLIPS 6.3 seems to be more friendly so you can install it with using Wine \break
\href{http://www.winehq.org/}{(\texttt{http://www.winehq.org/})} and just following the Windows tutorial.

\subsubsection*{How to install CLIPS in Mac OS X?}

First of all we have to download the program from the official website of CLIPS, you can find it here:\break
\href{http://clipsrules.sourceforge.net/}{\texttt{
(http://clipsrules.sourceforge.net/)} }. 

From the download section you can choose version for Mac OS X and intall it into your OS.


\subsection{Console environment VS command window}

Although the window environment is much more intuitive, the command line version of CLIPS is much faster (probably because it doesn't have to display at all facts, instances, rules, etc.).

The speed difference is very noticeable in the case of performance problems or
sensation that the environment remains hung windows (or directly quits
without notice), we recommend you to test the command line version.


\section{The Facts}

\subsection{What is a fact in CLIPS?}
Conceptually, an abstract data is a fact which store values. You can see a list of fields, where the first field refers to the ``data'' to which we attach a list of values that inherits
%%suceden -- maybe "follows"
, having a relationship with each other.

Formally, the first field is a symbol and the remaining fields are values.

\medskip

\texttt{(symbol  value1 value2  ...  valueN)}

\subsection{¿Qué es un hecho ordenado (order Facts)?}

Un hecho ordenado tienen formato libre, por lo tanto no existe restricción alguna en el orden de los campos. Los campos de un hecho ordenado pueden ser de cualquier tipo primitivo de datos, excepto el primero, que debe ser un símbolo.
Como ejemplo tenemos:


\begin{verbatim}
(hermanos Antonio Javier Carlos)
(padre Pedro David)
(num-hijos Pedro 2)\end{verbatim}

\subsection{¿Qué es un hecho no ordenado (deftemplates facts)?}



A través de los hechos no ordenados podemos abstraernos de la estructura de un hecho, asignado  un nombre a cada campo (slots).

\begin{verbatim}
  (deftemplate   nombre-template   "comentario"
       (slot nombre-slot  (tipo-del-slot))
       (multislot nombre-slot  (tipo-del-slot))
  )
\end{verbatim}

Por ejemplo:

\begin{verbatim}
(deftemplate avión
        (slot nombre_avion (type STRING))
        (slot compania (type STRING))
        (slot numero_plazas (type INTEGER) (default 100))
)\end{verbatim}

\subsection{¿Puedo tener un vector como slot?}

Si, debe declararse como multislot.

\subsection{¿Puedo asignar propiedades a los slots?}

Sí, las más importantes son:
\begin{description}
 \item[Type:]
 El tipo de dato primitivo que contiene (en mayúsculas).
\item [Allowed-X:] Permite especificar un conjunto de valores permitidos. Siendo \texttt{X} un tipo
de datos primitivo (en minúsculas y plural) $\rightarrow$ si el slot toma un valor del tipo
\texttt{X} debe pertenecer a los valores permitidos. \texttt{X} puede ser \texttt{values}
especificando entonces todos los valores posibles que puede tomar el slot independientemente del
tipo de dato.
\item [Range:] Especifica un rango para slots numéricos.
\item [Cardinality:] Números mínimo y máximo de elementos que puede tener un multislot.
\item [Default:] Valor por defecto. Si ponemos \texttt{?NONE} como valor por defecto significará que
no se podrá crear la instancia a no ser que se especifique el valor de ese slot.
 \end{description}

\begin{verbatim}
(deftemplate estudiante
 (slot edad (type INTEGER) (range 0 99))
 (multislot asignaturas (type STRING) (cardinality 1 5))
 (slot num-carreres (default 1))
 (multislot notas (allowed-strings "MH" "NP"))
)
\end{verbatim}

\subsection{¿Qué debo utilizar, hechos ordenados o no ordenados?}

Como se puede intuir si tenemos un conjunto de hechos los cuales conceptualmente pertenecen al mismo ámbito, será una solución más elegante agruparlos a través de un deftemplate. En caso que tengamos que algún hecho aislado, será mas sencillo declararlo como un hecho ordenado.




\subsection{Fets o Objectes?}


Veient la definició de deftemplate podem confondre'ns a l'hora de decidir si fer servir fets o fer servir objectes.

Deixant de banda altres diferències ja comentades (les classes suporten
jerarquia de classes, herència, etc..), els objectes es fan servir per
representar el coneixement (mitjançant un conjunt d'instàncies).

Així que, generalment, farem servir classes i objectes per representar coneixement, mentre que farem servir els fets per portar control sobre l'execució del problema.

Per exemple, podríem definir un deftemplate per emmagatzemar un resultat o per poder controlar l'estat de l'execució.

A la pràctica de Mikeo (penjada a la web de l'assignatura) teníem un deftemplate \texttt{habitacion-actual}

\begin{verbatim}
(deftemplate habitacion-actual
 (slot habitacion)
 (slot area-restante)
 (slot presupuesto-restante)
 (slot precio-total)
 (slot prioridad-actual)
)
\end{verbatim}

Amb el qual controlàvem la construcció d'una habitació. Assignàvem una instància de la classe
habitació al slot \texttt{habitacion} de \texttt{habitacion-actual} i mitjançant una sèrie de regles
que feien unificació amb \texttt{habitacion-actual} actuàvem sobre l'habitació d'una manera o d'un
altre.

\subsection{Creación de hechos (assert/deffacts)}

Si queremos crear un solo hecho utilizaremos el comando \texttt{assert}. Por ejemplo:
\texttt{(assert (casa roja))}

Si por el contrario queremos crear una estructura ordenada de hechos utilizaremos deffacts:
\medskip

\texttt{(deffacts mishechos (casa roja) (pelota azul))}




\subsection{Modificar un fet}


Per modificar un fet (per exemple, molt útil si estem treballant amb deftemplates) ho podem fer mitjançant \texttt{(modify <INSTANCIA> <FETS>)}.

Per exemple, si tinguéssim el deftemplate persona

\begin{verbatim}
(deftemplate persona
 (slot nom)
 (slot edad)
 (slot dni)
) \end{verbatim}

I haguéssim afegit el fet:

\begin{verbatim}
(assert (persona (nom "Pepe")(edad 25)(dni "46974431")))\end{verbatim}

I el fet:

\begin{verbatim}
(assert (aniversari "46974431"))
\end{verbatim}

Podríem tenir la següent regla:

\begin{verbatim}
(defrule aniv
  ?aniversari <- (aniversari ?dni)
  ?persona <- (persona (edat ?edat)(dni ?dni))
  =>
  (retract ?aniversari)
  (modify ?persona (edat (+ 1 ?edat)))
)
\end{verbatim}

La qual s'activarà si hi ha un fet aniversari d'una persona. Fent servir el dni indicat al fet
aniversari, busquem el fet persona que té el mateix dni. Deixem el valor edat a la variable
\texttt{?edat} per poder treballar amb ella més endavant.

Hem agafat també la direcció del fet aniversari per tal de poder esborrar-lo de la base de fets. Això s'ha fet per dues raons:

Primer, per mantenir més neta la base de fets.
Segon, i més important: Com que hem canviat el fet, la regla tornarà a fer unificació amb el fet
(perquè ara és diferent) amb la regla aniversari, amb el que entraria dintre d'un bucle sense fi on
s'aniria incrementant l'edat de la persona.

Un cop hem esborrat el fet aniversari, incrementem en 1 el valor del slot \texttt{edat} de  la
persona, fent servir la variable \texttt{?edat} que hem declarat a la part esquerre de la regla.

\subsection{Com elimino un fet de la base de fets?}


Per eliminar un fet de la base de fets ho podem fer amb la paraula clau
\texttt{(retract
<FET>)}, on \texttt{<FET>} és un punter al fet.

Per obtenir aquest fet, ho podem fer fent servir \texttt{<VAR> <- <FET>} a la
part esquerre de la regla.

Per exemple:

\begin{verbatim}
(defrule accionsvent
 ?vent <- (vent ?tipus)
 =>
 (switch ?tipus
    (case poc then (assert (accio persiana0)))
    (case normal then (assert (accio persiana50)))
    (case molt then (assert (accio persiana100)))
 )
 (retract ?vent)
)
\end{verbatim}

Afegirà fets per realitzar les accions pertinents i esborrarà el fet de la base
de fets.


\section{Variables}
\subsection{Variables a clips}


No cal declarar una variable (ni el seu tipus), només cal afegir un interrogant
al començament d'un simbol per indicar que és una variable.

CLIPS s'encarrega del control de tipus depenent del que assignem a la variable.

Per exemple, \texttt{?testvar} correspondria a la variable \texttt{testvar}. Si
per exemple, assignéssim l'enter \texttt{3} a \texttt{?testvar} CLIPS tractaria
la variable com una variable entera.

\subsection{Com assignar un valor a una variable?}


Per assignar un valor a una variable es fa servir el mètode \texttt{(bind)}, amb
la forma:
\medskip

\texttt{(bind <VARIABLE> <VALOR>)}
\medskip

On \texttt{<VALOR>} pot ser un valor o un mètode que retorni un valor.
Per exemple, si volem assignar un 4 a la variable \texttt{?var}:
\medskip

\texttt{(bind ?var 4)}
\medskip

O per exemple, podríem assignar a la variable \texttt{?var} la suma de 2 més 2:
\medskip

\texttt{(bind ?var (+ 2 2)) }

\subsection{¿Cómo declarar variables globales?}

Para crear una variable global hay que meterla dentro de la construcción defglobal. La declaración de la variable seguirá el modelo:   \texttt{ ?*nombreVariable* = expresión}

Por ejemplo:
\medskip

\texttt{(defglobal ?*presupuesto* = 0)}
\medskip

Pueden aparecer en la parte izquierda de las reglas si no son utilizadas para asignar un valor y su cambio no activa reglas, pero no pueden ser parámetros de funciones ni métodos.

\subsection{¿Cómo trabajar con variables, sumando, restando, ... por ejemplo
contadores?}

La mejor forma es con variables globales, se definen así
\texttt{(defglobal ?*x* = 0)}, puede ser el valor que queramos, tanto número,
string, ...
Y si queremos sumarle 10 por ejemplo:
\medskip

\texttt{(bind ?*x* (+ ?*x* 10))}
\medskip

Las variables locales, como por ejemplo \texttt{?x}, sólo tienen valor mientras
dura su ejecución y eso suele ser en esa misma línea o en un bucle. Si le damos
valor a \texttt{?x} y luego preguntamos por ella, nos dirá que no existe.

\subsection{Quina diferència hi ha entre les variables del tipus
{\tt ?nom\_variable} i les del tipus {\tt \$?nom\_variable}?}

Les primeres contenen un sol valor, i les segones en poder contenir més d'un (o
cap).


\subsection{Què significa l'interrogant (?) quan va sol?}

És una variable anònima. Pots utilitzar \texttt{?} sense posar-hi cap nom si
no t'interessa el valor en concret.
Per exemple:
\medskip

\texttt{(Primer filtre\_preu ?)}
\medskip

Aquesta condició significa ``si el fet \texttt{(Primer filtre\_preu)} té algun
valor''. O sigui, que si tinguéssim el fet \texttt{(Primer filtre\_preu ok)} es
compliria la condició (i si en comptes de ``ok'' fos ``patata'' també es
compliria). En canvi, si el fet fos únicament \texttt{(Primer filtre\_preu)} no
es compliria la condició.

\subsection{Què significa el dòlar (\$) quan va sol?}

És com l'interrogant, però admet més d'un valor. Per exemple:
\medskip

{\tt (Primer filtre\_preu \$ ok)}
\medskip

donarà cert pels fets de l'estil \texttt{(Primer filtre\_preu patata ok)},
\texttt{(Primer filtre\_preu hola ok)}, \texttt{ (Primer filtre\_preu patata
hola ok)},
\texttt{(Primer filtre\_preu ok)}.
És a dir, no importa els valors que hi hagi entre \texttt{filtre\_preu} i ok, si
al final hi ha un ok.

\subsection{¿Como puedo ver los hechos presentes en un momento determinado?}

Abriendo la Facts Window en Window de la barra de menú.


\section{Las reglas}

\subsection{¿Cómo construir una regla?}

Para construir una regla utilizaremos la construcción defrule:

Sintaxis:

\begin{verbatim}
(defrule <nombre-regla> [<comentario>]
  [<declaración>]
  <elemento-condición>* ; Parte izquierda (LHS)
   =>
  <acción>*) ; Parte dcha. (RHS) de la regla
\end{verbatim}

Una regla consta de un conjunto de condiciones (antecedente), también
denominados elementos condicionales (EC) o parte izquierda (LHS), y de un
conjunto de acciones (consecuente), también denominado parte derecha de la regla
(RHS). La regla se activará siempre que se satisfagan todos los EC mediante
hechos o instancias que los cumplan.

Si se introduce en la base de reglas una nueva regla con el mismo nombre que el de una
existente, la nueva regla reemplazará a la antigua.

Si una regla no tiene parte izquierda, es decir, no tiene elementos condicionales, entonces
el hecho \texttt{(initial-fact)} actuará como el elemento condicional para ese tipo de
reglas, y la regla se activará cada vez que se ejecute un comando reset.


\subsection{¿Cómo gestionar la parte izquierda (LHS) de una regla?}

\subsubsection*{Declarar hechos}


Si no se especifica ninguna condición la regla se activará siempre. 
Una condición puede ser un simple hecho (Ej. \texttt{vegetariano}) o un hecho
ordenado con unos valores concretos (Ej. \texttt{(persona (nombre Juan))}).
Si lo que queremos es obtener el valor de un hecho insertaremos una variable en
su lugar (Ej. \texttt{(persona (nombre ?n))} ). Entonces entrará en la regla
para cada valor posible que pueda asignar a la variable \texttt{?n} a partir de
los
hechos.

Si queremos indicar cualquier valor utilizaremos el símbolo \texttt{?} y para
cualquier
lista el símbolo \texttt{\$?} (Ej. \texttt{(evento ?) (estilo \$?)} ).
También existe la opción de guardar en una variable una referencia al objeto.
Ello se consigue poniendo \texttt{var <-} a su izquierda (Ej. \texttt{?p <-
(persona
(nombre Juan))}). Se puede usar por ejemplo para pasárselo de parámetro a una
función llamada en la RHS.


\subsubsection*{Establecer condiciones}

Además podemos especificar restricciones adicionales sobre los valores que puede
tomar un campo de un hecho. Existen tres tipos principales de restricciones: 
Conectadas (por orden de precedencia o prioridad) 
\begin{description}
 \item not (\verb|~|):
  Evita que cierto campo cumpla determinada restricción. 
\item and (\verb|&|): Combina dos restricciones conjuntivamente. 
\item or (\verb+|+): Combina dos restricciones disjuntivamente. 
\item De predicado (\verb|:|) : Obliga a que cierto campo cumpla determinada
condición (especificada por el predicado). 
\item Por valor devuelto por una función \verb|=|: Permite llamar a una función
y utilizar el valor devuelto para restringir el valor que pueda tomar un campo
de un hecho. 

Se puede comprobar si se cumple una determinada condición mediante el
constructor
\texttt{test}. Dentro de \texttt{test} se pueden hacer llamadas a cualquier
función o predicado, ya
sea primitiva de CLIPS o definida por nosotros.
\end{description}

\subsubsection*{Combinar elementos}


Los diferentes elementos de la parte izquierda van
implícitamente unidos mediante una \texttt{AND}, que indica conjunción. No
obstante podemos hacerlo explícitamente mediante \texttt{(and (cond1) (cond2))},
aunque suelen utilizarse para anidar \texttt{ANDs} dentro de \texttt{ORs}.

\texttt{OR} Sirve para hacer una disyunción \texttt{(or (cond1) (cond2))}. Es
equivalente a escribir varias reglas en las que cada una de ellas tenga uno de
los componentes del OR en su parte izquierda, y la misma parte derecha.

\texttt{NOT} Sirve para detectar si no existe un determinado hecho (Ej. 
\texttt{(not (estilo sibarita)))}. 

\texttt{exists} Cuando a un conjunto de elementos se le antecede exists, se
comprueba que hay al menos un hecho en la base de hechos que cumpla la condición
(Ej. \texttt{(exists(bebida ?precio: (< ?precio 5)))} )

\texttt{forall} Permite comprobar si todos los hechos que satisfacen un
determinado patrón, cumplen una serie de condiciones (Ej. \texttt{(forall(plato
(estilo moderno))})




\subsection{¿Cómo obtener la dirección de hechos o instancias situados en LHS?}

En algunas ocasiones, vamos a necesitar realizar algún tipo de acción en la parte derecha de las reglas sobre hechos o instancias que cumplan unas determinadas condiciones. Pero para ello necesitaremos primero tener acceso a estos elementos para después poder operar sobre ellos. Esto lo conseguiremos guardando la dirección del elemento en una variable haciéndolo del siguiente modo:
\medskip

\texttt{?variable\_direccion <- (elemento)}
\medskip


Pongamos un ejemplo para ver realmente el funcionamiento y uso de esta posibilidad que CLIPS nos ofrece:

\begin{verbatim}
(defrule imprime-area
  ?instancia <- (object (is-a Rectangulo))
  =>
  (printout t "Area del rectangulo " (instance-name ?instancia) 
                             ":" (send ?instancia calcula-area) crlf)
)
\end{verbatim}

Cuando se ejecuta esta regla, se imprimirán las áreas de todas las instancias de
la clase \texttt{Rectangulo}. En la parte izquierda de la regla, lo que hacemos es
guardar en la variable instancia la dirección de la instancia de \texttt{Rectangulo} que
estamos tratando en ese momento. La regla se ejecutará para todas las instancias
almacenadas en la memoria de trabajo que cumplan la condición (\texttt{is-a
Rectangulo}), es decir, para todas las instancias de la clase
\texttt{Rectangulo}. En la parte derecha de la regla, donde se ejecutan las
acciones, podemos ver que se imprimirá, para cada instancia, lo siguiente:
\texttt{Area del rectangulo \texttt{[nombre\_instancia]}: área del rectángulo}.
La función \texttt{instance-name} nos devuelve el nombre de la instancia que le
pasamos por parámetro. Además, hemos llamado al gestor de mensajes \texttt{calcula-area}
para que nos devuelva el area del rectángulo.

\subsection{¿Cómo hacer sentencias or en la izquierda de las reglas?}

Con \texttt{(or ...)}. Si por ejemplo tenemos dos hechos \texttt{(a)} y \texttt{(b)} y queremos
ejecutar la derecha de la regla cuando se cumpla uno de los dos, tendremos que hacer \texttt{(or (a)
(b))}. Atención porque la parte derecha se ejecutará tantas veces como veces se cumpla cada uno de
los hechos, si para nosotros existe tanto \texttt{(a)} como \texttt{(b)}, la parte derecha se
ejecutará dos veces. Para que sólo se usa una vez, podemos hacer combinaciones de or y and (funciona
igual) o usar un patrón, por ejemplo \texttt{(persona Juan|Pedro)} sólo se ejecutaría una vez.


\subsection{Com afegir una condició a la part esquerre d'una regla?}


A vegades és necessari que una regla s'instanciï si es produeix una condició especial (i no un fet).
Per fer aixó, farem servir la comanda \texttt{(test <CONDICIO>)}.

Per exemple, imaginem que la nostre base de fets compte amb un fet \texttt{(preu
?valor)} amb un preu determinat. Imaginem que volem una regla que s'instanciï
quan aquest valor és més gran que 30.

Per fer-ho, fent servir tot el que hem explicat,

\begin{verbatim}
(defrule preucar
 (preu ?preu)
 (test (> ?preu 30))
 =>
 (printout t "El preu es mes gran que 30")
)
\end{verbatim}

És a dir, si el preu és més gran que 30 s'imprimirà un missatge per pantalla.

Aquestes condicions poden contenir ANDs i ORs de varies condicions.

Per exemple,

\begin{verbatim}
(defrule preulimit
  (preu ?preu)
  ?factminim <- (preuminim ?minim)
  ?factmax <- (preumaxim ?maxim)
  (test (and (> ?preu ?minim) (< ?preu ?maxim) ))
   =>
  (retract ?factminim)
  (retract ?factmax)
  (printout t "El preu està dintre del rang")
) \end{verbatim}

On comprovarem si el preu està dintre d'un rang determinat i en aquest cas, esborra els fets que contenen el màxim preu i el mínim preu i mostra un missatge per pantalla.


\subsection{Puede una misma regla ejecutarse más de una vez?}

Es muy importante entender que cada regla se ejecutará una vez por cada
combinación de valores en su LHS.


\begin{verbatim}
(defrule regla 
   (color ?col)
   (peso ?pes)
 =>
...
\end{verbatim} 

Si tengo tres colores y dos pesos asertados la regla se ejecutará 6 veces, una
con cada combinación de color y peso. 




\subsection{Com puc definir l'ordre de les regles?}

La idea d'un sistema basant en regles és no definir un ordre lineal d'aquestes
(costa deixar de pensar de forma iterativa)

En el cas de necessitar que una regla s'executi després d'una altre, pots fer
servir Fets: la regla anterior crea un fet, que la segona regla tindrà a la part
esquerra:

\begin{verbatim}
(defrule pregunta1
 =>
 (assert (pregunta1Feta))
 ....
)

(defrule pregunta2
 (pregunta1Feta)
 =>
 ....
)
\end{verbatim} 

I finalment, pots usar la propietat \texttt{salience}. Aquesta propietat indica
la prioritat d'execució de les regles ( les regles amb salience majors
s'executaran abans ). Pot prendre valors positius i negatius entre -10.000 y
+10.000. Per defecte les
regles tenen salience 0:

\begin{verbatim}
(defrule pregunta1
 (declare (salience 2))
 =>
 ....
)

(defrule pregunta2
 (declare (salience 1))
 =>
 ....
)
\end{verbatim} 

El valor indicado en la propiedad \texttt{salience} puede ser el número
directamente o una expresión, por ejemplo \texttt{variable*10},
podemos usar \texttt{variable} para elegir que regla se ejecutará. 

Las prioridades deben ser usadas solo para determinar el orden en el que se
disparan algunas reglas sobre otras, no para fijar el flujo de control ya que la
principal ventaja de un sistema basado en reglas es la representación
declarativa del conocimiento y de esta forma, abusando de las prioridades,
conduce a un sistema procedimental.




\subsection{Com forçar que una regla sigui la primera?}

Per que aquesta regla sigui la primera ha de tenir el salience més gran de
totes.

\begin{verbatim}
(defrule presentacio
 (declare (salience 20))
 =>
 (printout t "------ Benvingut -----" crlf)
)
\end{verbatim} 

\subsection{Vull guardar certs valors que es fan servir durant l'execució de diferents regles. Com ho puc fer?}

Tens principalment dues alternatives. Si el valor és un tipus bàsic, pots fer servir una variable global, amb la sintaxi següent:
\medskip

\texttt{(defglobal ?*nom\_variable* = valor)}
\medskip


Aquesta sentència no va a dins de cap funció ni regla, es posa sola a la part que creguis convenient del codi.
Vegem un exemple:
\medskip

\texttt{(defglobal ?*preu\_minim\_primer* = 1000)}
\medskip


Per fer-la servir es fa exactament de la mateixa manera que amb una variable normal, però has de posar els dos asteriscs. Per exemple:
\medskip

\texttt{(bind ?*preu\_minim\_primer* ?curr-preu)}
\medskip

Per altra banda, si el valor o valors que vols guardar han de ser instàncies, una bona estratègia pot ser utilitzar un deftemplate. És útil sobretot per anar guardant solucions temporals, o llistes d'elements que poden formar part de la solució.

Per utilitzar-ho has de seguir els passos següents.

\begin{enumerate}
 \item  Definir el deftemplate:


\begin{verbatim}
(deftemplate nom_del_deftemplate
  (multislot nom_multislot)
   ...
  (slot nom_slot)
)
\end{verbatim}

Amb un exemple es veurà més clar:

\begin{verbatim}
(deftemplate llista-plats
 (multislot primers)
 (multislot segons)
 (multislot postres)
)
\end{verbatim}

\item Inicialitzar el deftemplate

\begin{verbatim}
(defrule
  [condicions vàries]
  ; La condició base és que llista-plats no s'ha inicialitzat encara.
  (not (llista-plats))
=>
  ; ?llista conté els valors de llista-plats (que de moment estan buits)
  (bind ?llista (assert (llista-plats)))
\end{verbatim}

\item  Assignar-li valors

\begin{verbatim}
(bind ?segons_plats (find-all-instances ((?plat Plat)) TRUE)
(modify ?llista (segons ?segons_plats))
\end{verbatim}

\item Recuperar els valors

\begin{verbatim}
(defrule
  [condicions vàries]
  ?llista <- (llista-plats (segons $?segons_plats))
=>
  ...
\end{verbatim}

Ara, la variable \texttt{\$?segons\_plats} conté tots els elements de segons.


\end{enumerate}



\section{Las clases/instancias}

\subsection{Tengo que representar la jerarquía de un frame ¿Es preferible añadir
las
subclases a la ontología o bien diferenciarlas mediante un slot en la
superclase?}


Las dos formas son válidas, pero es recomendable representarlas en clases separadas cuando se vayan a buscar instancias de ese tipo, ya que así no tendremos que hacer un recorrido por todas las de la superclase. No obstante, si sólo se trata de una característica puntual del frame y no vamos a hacer búsquedas de una exclusiva subclase entonces será más eficiente añadir un slot debido a su mejor accesibilidad.



\subsection{¿Qué es un objeto?}

Podríamos decir que un objeto, es un hecho no ordenado  con herencia.

\subsection{¿Porqué usar objetos en contexto de la práctica de
CLIPS de IA?}

Como bien sabemos, una parte de la práctica de SBC's consisten en crear la
ontología. Esta ontología se exporta para poder interactuar con CLIPS en formato
\texttt{.pins} y \texttt{.pont}. El archivo \texttt{.pont} contendrá la
declaración de todas las clases creadas previamente por Protege
\texttt{(defclass )}. El archivo \texttt{.pins} contendrá todas las instancias
de las clases declaradas en el archivo \texttt{.pont}. Como puede intuir el
lector, se necesitará interactuar con los objetos previamente creados por
Protègè.

\subsection{Como se definen las clases?}

Para definir las clases usaremos el constructor defclass:

\begin{verbatim}
(defclass  <nombre>  [<comentario>]
 (is-a  <nombre-de-superclase>)
 [(role concrete | abstract)]
 [(pattern-match reactive | non-reactive)]
 <slot>* ;;; definición de los atributos de la clase
<documentación-handler>*
)\end{verbatim} 

En caso de desear que la nueva clase herede las propiedades de otra ya
existente, el nombre de esta deberá especificarse despues de \texttt{is-a}. El
rol determinará si la clase es concreta (se puede instanciar) o abstracta
(destinada a ser superclase). El \texttt{pattern-match} debe declararse como
reactivo si
se desea que las instancias de la clase puedan unificar con los elementos
objeto
de las reglas (símbolo \texttt{<-}). Los \texttt{slots} corresponden a los
atributos de la
clase y los \texttt{handlers} a las funciones de ésta. Los handlers se pueden
declarar en
la declaración de la propia clase, pero se deben definir externamente. Dado que
no aporta ninguna ventaja declararlos es recomendable definirlos directamente.
Nótese que todo aquello que está entre corchetes (\texttt{[]}) constituye
información adicional que no es obligatorio especificar.

\begin{verbatim}
(defclass Persona
 (is-a Ser_Vivo)
 (role concrete)
 (single-slot edad
  (type INTEGER)
  (range 1 99)
  (cardinality 0 1)
  (create-accessor read-write)
 )
 (multislot amigos
  (type INSTANCE)
  (allowed-classes Persona)
 )
)
\end{verbatim} 

El comportamiento y declaración de los slots es idéntico al de los slots de los
hechos ordenados. Los atributos de tipo \texttt{INSTANCE} (referencian otras
instancias)
estan en formato \texttt{INSTANCE-NAME} .

\subsection{Com consulto una instància a partir d'una regla?}


Podem fer servir la part esquerre d'una regla per trobar instàncies. L'ús és
molt semblant a trobar el punter a un fet, fent servir
\medskip

\texttt{(object (is-a <NOM\_CLASSE>))}
\medskip

Per exemple, si volem que una regla s'instanciï si tenim instanciat un plat de
la classe Plat, podriem fer servir:

\begin{verbatim}
(defrule tenimplat
 ?plat <- (object (is-a Plat))
=>
(print t (send ?plat get-nom) crlf)
)\end{verbatim} 

La regla imprimirà el nom del plat que trobi. És important notar que s'activarà
per cada instància de plat que tinguem a la base de coneixement.

Podem consultar els valors de la instancia fent servir condicions a la part
esquerre de la regla. Per exemple, si només volguéssim els plats amb un preu més
gran que 30:

\begin{verbatim}
(defrule platcar
 ?plat <- (object (is-a Plat))
 (test (> (send ?plat get-preu) 30))
 =>
 (print t (send ?plat get-nom) " es car." crlf)
) \end{verbatim} 

S'activarà per tots els plats amb un preu major a 30.

S'ha d'anar amb cura per aquest tipus de regla, ja que si la base de coneixement
és molt amplia pot acabar derivant amb problemes de memòria.

Per exemple, si en comptes de preguntar per una instància de Plat, preguntéssim
per dues instancies de Plat:

\begin{verbatim}
(defrule platcar
 ?plat1 <- (object (is-a Plat))
 ?plat2 <- (object (is-a Plat))
 (test (> (send ?plat1 get-preu) 30))
 (test (> (send ?plat2 get-preu) 30))
 =>
 (print t (send ?plat1 get-nom) " i " (send ?plat1 get-nom)   " són cars."
crlf)
)
\end{verbatim} 

Faria unificació amb totes les combinacions possibles (amb repeticions) de dos
plats de tota la base de coneixement. Això es podria anar ampliant fins fer-se
intractable.


\subsection{¿Cómo realizar una búsqueda de instancias que cumplan unas
restricciones?}

CLIPS nos ofrece varias funciones de búsqueda de instancias que cumplan unas
determinadas restricciones que a nosotros nos interese:

\begin{itemize}
\item 
La función \texttt{find-instance}: Esta función devuelve la primera instancia
que cumple
todas las restricciones indicadas. 
\item La función \texttt{find-all-instances}: Esta función devuelve todas las
instancias que
cumplen las restricciones indicadas.
\end{itemize}

La sintaxis de ambas funciones es igual exceptuando el nombre de la función:

\texttt{(find-all-instances (clase\_instancias) (restricciones))}. 

A continuación se muestran varios ejemplos:

\begin{itemize}
\item 
\texttt{(bind ?rectangulos (find-all-instances ((?inst Rectangulo)) (>
?inst:altura
10)))}.  Después de ejecutar esta función, en la variable rectangulos habrá una
lista con todas las instancias de la clase Rectangulo cuya altura sea superior a
10. 

\item \texttt{(bind ?rectangulos (find-all-instances ((?inst Rectangulo)) (and
(>
?inst:altura
10) (= ?inst:anchura 7))))}. Este trozo de código hace que en la variable
rectangulos se guarde una lista de las instancias de la clase Rectangulo que
tienen una altura superior a 10 y una anchura igual a 7.\end{itemize}



Estas funciones que CLIPS nos ofrece tienen otra funcionalidad y es que podemos
realizar búsquedas de conjuntos de instancias:


\begin{itemize}
\item 
\texttt{(bind ?rectangulos (find-all-instances ((?a Rectangulo) (?b Rectangulo))
(=
?a:altura ?b:altura)))}. Con este trozo de código conseguiríamos obtener todas
las parejas de instancias de la clase Rectangulo que tienen la misma altura. 
\end{itemize}

Por último, es necesario comentar que se pueden realizar búsquedas de conjuntos
de instancias que sean de distintas clases:


\begin{itemize}
\item 
\texttt{(bind ?figuras (find-all-instances ((?rect Rectangulo) (?circ Circulo))
(=
?rect:altura ?circ:radio)))}. Con este trozo de código conseguiríamos obtener
todas las parejas \texttt{<rectangulo,circulo>} que cumplan que la altura del
rectángulo
sea igual al radio del círculo.\end{itemize}


Existen más comandos para obtener instancias, pero son menos utilizadas a nivel
básico, como pueden ser, \break \texttt{any-instancep}, \texttt{do-for-instance},
\texttt{do-for-all-instances} y \texttt{delayed-do-for-all-instances}.




\subsection{¿Cómo se interactúa con objetos?}

La interacción con objetos se efectúa mediante lo que se denomina mensaje. 

\begin{verbatim}
(defmessage-handler
  <nombre-clase>
  <nombre-mensaje>
  [<tipo-handler>] [<comentario>]
  <parámetro>* [<parámetro-comodín>])
  <acción>*
)\end{verbatim} 

Un gestor de mensajes consta de 7 partes:
\begin{enumerate}
\item  Nombre de clase  a la que el gestor estará asociado
\item Nombre del mensaje
\item Tipo de gestor (Nosotros habitualmente usaremos primary que viene por
defecto)
\item Comentario (opcional);
\item Lista de parámetros
\item Parámetro comodín (para gestionar múltiples parámetros)
\item Secuencia de acciones o expresiones que serán ejecutadas por el gestor
\end{enumerate}

Enfocado a la práctica de CLIPS, la más común es que queramos interactuar con
objetos para:

\begin{enumerate}
 \item  Imprimir los objetos
 Un ejemplo:

\begin{verbatim}
   (defmessage-handler avion imprimir-beneficio ()
     (printout t (send ?self imprimir-beneficio) crlf)\end{verbatim} 

\item Para implementar funciones calculadas asociadas al objeto
 Un ejemplo:

\begin{verbatim}
 (defmessage-handler avion calcular-beneficio ()
  (* ?self:plazas-ocupadas ?self:precio-billete)) 
 )
\end{verbatim} 
\end{enumerate}

Como se puede observar el parámetro implícito \texttt{?self}, contiene la
instancia activa para este mensaje.

\subsection{¿Como se interactúa con las instancias de los objetos?}

Podremos interactuar entre las instancias de los objetos mediante la función
\texttt{send}.
\medskip

\texttt{(send <expresión-de-objeto> <nombre-de-mensaje>   <expresión>*)}
\medskip

Donde se toman como argumentos el objeto destino del mensaje, el mensaje mismo,
y otros parámetros que debieran ser pasados a los gestores.

Particularmente, en el ámbito de la práctica, usualmente necesitaremos
utilizar el
envió de mensajes de tipo \texttt{get}, \texttt{put} and \texttt{delete}.
Estos mensajes tiene la siguiente sintaxis:

\begin{itemize}
\item \texttt{get-<nombre-atributo>}
\item \texttt{put-<nombre-atributo>}
\item \texttt{delete}
\end{itemize}


Aquí tenemos un ejemplo de como utilizarlo, recordando que ponemos entre
corchetes la instancia la cual se envía el mensaje  

\begin{verbatim}
(defclass avion (is-a USER)
     (role concrete)
     (slot precio-billete (create-accessor read) (default 34))
     (slot plazas-ocupadas (create-accessor write) (default 0)))
;Clase creada

>(make-instance a of avion)         ;Creación de una instancia de avion
[a]
>(send [a] get-precio-billete)      ;Obtención de un slot
34                                  ;Resultado obtenido
>(send [a] put-plazas-ocupadas 100) ; Modificación de un slot
>(send [a] delete)                  ; Eliminación de la instancia
True
\end{verbatim} 


\subsection{Uso de make-instance}

Cuando queremos crear una instancia de una clase para ir rellenandola con los
resultados o datos que vayamos obteniendo se haria lo siguiente:
\medskip

\texttt{(bind ?variable\_instancia (make-instance nombre\_instancia of
nombre\_clase))}
\medskip

Una vez creada, podemos jugar con dicha instancia en las diferentes reglas,
siempre que la llamemos en los activadores:

\begin{verbatim}
(defrule regla
 ?var_instancia <- (object (is-a nombre_clase))
 => 
 ...
)\end{verbatim} 

De esta manera dentro de la regla podemos hacer acciones con la instancia, por
ejemplo:
\medskip

\texttt{(send ?var\_instancia put-articulo ?articulo\_ejemplo)}

\subsection{Com fer un get/set d'un slot d'una classe?}


Per consultar el valor d'un slot d'una classe, ho podem fer enviant-li un
missatge de la següent manera:
\medskip

\texttt{(send <VARIABLE> get-<NOM\_ATRIBUT>)}
\medskip

Per exemple, si tenim una instància de la classe Plat ( \texttt{?instancia} ) i
volem saber el valor del seu slot nom:
\medskip

\texttt{(send ?instancia get-nom)}
\medskip

Per assignar un valor a un slot d'una d'instància, hem d'enviar-li un missatge
de la següent manera:
\medskip

\texttt{(send <VARIABLE> put-<NOM\_ATRIBUT> <VALOR>)}
\medskip

On \texttt{<VALOR>} pot ser un valor o un mètode que retorni un valor.
\medskip

\texttt{(send ?instancia put-nom "nom")}


\subsection{¿Cómo acceder a una instancia cuyo nombre conocemos?}

Si conocemos el nombre de una instancia y necesitamos acceder a ella, es decir,
necesitamos enviarle algún mensaje mediante la función send, podemos hacerlo
directamente escribiendo, en lugar de la variable que almacena la instancia, el
nombre de la instancia entre corchetes \texttt{[ ]}. A continuación se muestra
un ejemplo:
\medskip

\texttt{(bind ?altura\_rect1 (send [rect1] get-altura))}
\medskip

 En este caso, se
guardará en la variable \texttt{altura\_rect1} el valor de la altura de la
instancia que tiene como nombre \texttt{rect1}.


\subsection{Obtenir el nom d'una classe}


Si tenim una instància d'una classe i volem saber el nom de la classe (útil si
tenim una bona taxonomia de classes) ho podem fer amb el mètode \texttt{(class
<INSTANCIA>)}.

Si per exemple, imaginem que tenim la classe Actor, la qual té com subclasses la
classe APrincipal, ASecundari  i ACameo. Imaginem que estem tractant amb
instancies d'actors, i volem saber si la instancia que estem tractant es de la
classe APrincipal.

Ho hauríem de fer de la següent manera:
\medskip

\texttt{(eq (class ?instancia) APrincipal)}
\medskip

Fixem-nos que \texttt{APrincipal} és un símbol, no un String (un truco és
fixar-se en que
no té cometes). Si volguéssim comparar-ho amb un String (per exemple, un String
introduït per l'usuari) ho podríem transformar a un String amb el mètode
\texttt{str-cat}.
\medskip

\texttt{(eq (str-cat  (class ?instancia)) "Principal")}


\subsection{Como convierto un INSTANCE-ADRESS en un INSTANCE-NAME?}

En algún momento nos podemos encontrar con la situación de que disponemos de un
puntero a una instancia y necesitamos su nombre o lo contrario. En ambos casos
podemos usar la función instance-name. Su funcionamiento es bidireccional,
podemos introducirle un instance-name y nos devolverá un instance-adress y
viceversa.

\begin{verbatim}
(defrule imprimir-nombre
 ?est<-(object (is-a Estudiante) (edad 25))
 =>
 (printout t (instance-name ?est) crlf)
)
\end{verbatim} 

\subsection{Com iterar a través d'un multi-slot?}


El següent també és vàlid com exemple de com iterar a través d'una llista.

Imaginem que tenim una instància de la classe Plat a la varible
(\texttt{?plat}), la qual té un
multi-slot d'instàncies de la classe Ingredient. Imaginem que volem imprimir per
pantalla el nom d'aquests ingredients (slot nom de la classe Ingredient):
Necessitarem iterar sobre la llista d'ingredients.

\begin{verbatim}
(bind ?i 1)
 (while (<= ?i (length$ (send ?plat get-ingredients)))
  do
  (bind ?ingredient (nth$ ?i (send ?plat get-ingredients)))
  (printout t (send ?ingredient get-nom) crlf)
 (bind ?i (+ ?i 1))
)
\end{verbatim} 

El mètode \texttt{(nth\$ <INDEX> <LLISTA>)} et retorna l'element situat a
\texttt{INDEX} de \texttt{LLISTA}. 

El mètode \texttt{(length\$ <LLISTA>)} retorna el número d'elements de LLISTA.


\subsection{Cómo recorrer un atributo multievaluado}

Supongamos que la variable respuesta tiene una lista de instancias

\begin{verbatim}
(loop-for-count (?i 1 (length$ ?respuesta)) do  
 (bind ?aux (nth$ ?i ?respuesta)) 
 ;aquí hacemos lo que queramos 
 ) 
) \end{verbatim} 
 
\texttt{Loop-for-count} funciona como un for, primero la variable que hará
de contador, luego el valor de origen y luego el valor final. Para controlar el
final usamos la función que he explicado antes.
\texttt{i} tomará valores desde 1 hasta n, así que usando la función
\texttt{nth\$} obtendremos cada uno de los elementos. La variable \texttt{?aux} irá
teniendo cada uno de los valores.

\subsection{Cómo recorrer un atributo multievaluado de un atributo multievaluado
(una
matriz).}

Es igual que antes pero con dos bucles


\begin{verbatim}
(loop-for-count (?i 1 (length$ ?respuesta)) do 
 (bind ?aux (nth$ ?i ?respuesta)) 
 (bind ?aux2 (send ?aux get-slot_que_queremos)) 
 (loop-for-count (?j 1 (length$ ?aux2)) do 
  (bind ?aux_final (nth$ ?j ?aux2)) 
  ;aquí ya podemos trabajar con el elemento en concreto
 ) 
) 
\end{verbatim} 

Supongamos que respuesta tiene una lista de instancias, con el primer bucle
haremos lo mismo que antes, ir iterando por esas instancias. Una vez que tenemos
cada instancia con \texttt{aux2}, con el segundo bucle iteraremos dentro de sus
instancias interiores.

Por ejemplo, si tenemos varios equipos de fútbol y cada equipo tiene varios
jugadores, en el primer bucle estamos iterando entre los equipos y en el segundo
entre los jugadores de cada equipo en particular.


\subsection{Com puc esborrar una instància?}


Per esborrar una instància (per exemple, segons la informació que proporcioni
l'usuari podem deduir que una sèrie d'instàncies és impossible que es facin
servir per a la solució) ho podem fer enviant un missatge delete a la instància,
és a dir \texttt{(send <INSTANCIA> delete)}. 
\medskip

\texttt{(send ?inst delete)}
\medskip

Un mètode que podria ser útil de la cara a la pràctica podria ser el següent:

\begin{verbatim}
(defrule elimina-instancia
 (declare (salience 10))
 ?elimina-fact <- (elimina-inst ?inst)
 =>
 (send ?inst delete)
 (retract ?elimina-fact)
)\end{verbatim} 

Imaginem que per exemple que volem eliminar una llista d'instàncies. Per
eliminar-les, podríem recórrer el llistat marcant les instàncies que volem
esborrar afegint el següent fet:
\medskip

\texttt{(assert (elimina-instancia ?inst))}
\medskip

Així, com que elimina-instancia té un salience alt esborraria les instàncies
marcades quan tingués ocasió.

D'aquesta manera ens estalviem el problema de recórrer un llistat d'instàncies
amb un iterador mentre anem eliminant els elements de la llista, cosa que pot
donar problemes amb l'iterador.


\subsection{Com imprimir una instància?}


Per imprimir una classe (útil per exemple per mostrar el resultat final) el
millor és definir message-handlers.

Per exemple, imaginem que tenim una classe \texttt{Plat}, la qual té un slot
\texttt{nom} de tipus String. Si volguéssim imprimir per pantalla un
missatge que digués:
\medskip

\texttt{El nom del plat és --<nom del plat>--}
\medskip

Hauríem de definir un message-handler que simplement imprimís per pantalla el
valor de l'slot, de la forma:

\begin{verbatim}
(defmesssage-handler <CLASSNAME> <MESSAGENAME> primary ()
   <CODI>
)
\end{verbatim} 

Per el cas de l'exemple: 

\begin{verbatim}
(defmessage-handler Plat print primary ()
 (printout t "--" ?self:nom "--") )
)
\end{verbatim} 

Per cridar-ho, només caldrà enviar-li un missatge a la instància amb el nom del
message-handler (en aquest cas, \texttt{print}).
\medskip

\texttt{(send ?instancia print)}
\medskip

Un message-handler pot cridar a altres message-handlers, amb el que es poden
encadenar diverses instàncies. Per exemple, imaginem que tenim la classe Menú,
la qual té un atribut plats que és un llista d'instàncies de la classe Plat.
Dintre del message-handler menú, podríem iterar a través de la llista de plats
enviant el missatge print que hem definit anteriorment.

	
\subsection{Com es navega entre instàncies relacionades?}
 Per exemple, tinc una instància iA
que té un slot anomenat slotB que és una instància d'un frame B. Vull saber el
nom de la instància associada al slotB de iA.
Ho pots fer així:

\begin{verbatim}
(bind ?B (send ?iA get-slotB))
(bind ?res (send ?B get-nom))
\end{verbatim} 

Si estàs dins d'una condició, ho pots simplificar de la forma següent:
\medskip

\texttt{(bind ?res (send ?iA:slotB get-nom)}
\medskip

Els dos punts són equivalents al punt de
Java



\section{Programación}
\subsection{Com introduir un comentari?}


Els comentaris a CLIPS va darrere de un\texttt{;}, com per exemple:
\medskip

\texttt{;Comentari}
\medskip

També podem afegir comentaris a les nostres regles, deffacts, deftemplates,
etc. Generalment van darrere el nom de la estructura, per exemple:

\begin{verbatim}
(defrule neteja "regla per la qual si la cuina està bruta s'afegirà una tasca de
neteja"
 (estat-cuina bruta)
  =>
 (assert (tasca netejar))
)
\end{verbatim}

\subsection{Referenciar el valor null a CLIPS?}


Per referenciar el valor null a clips es fa amb el simbol \texttt{nil}. Per
exemple, si volem saber si una instància \texttt{?inst} es null, ho podríem fer
de la següent manera:
\medskip

\texttt{(eq ?inst nil)}


\subsection{Formas de recorrer una lista:}

Para recorrer una lista disponemos de diferentes opciones, en este FAQ
explicaremos como crear una estructura tipo ``WHILE'' y tipo ``FOR''.

\begin{enumerate}
 \item \texttt{While}: Esta regla se ejecuta hasta que la expresión a evaluar sea falsa. Este tipo de
 estructura se rige por seguir la sintaxis \texttt{while} - \texttt{do}, y se construiría de la
siguiente forma:


\texttt{(while  <expresión>  [do]  <acción>)}

	Dónde dependiendo del valor de  \texttt{<expresión>}:

\begin{itemize}
 \item Valor  TRUE: Se realizará la acción \texttt{<acción>} i se volverá a evaluar \texttt{<expresión>}.
\item Valor  FALSE:  No se ejecutará la acción \texttt{<acción>}

\end{itemize}



\item \texttt{For}: Esta regla sirve para ejecutar un bucle N (final - inicio) veces. Este tipo de
estructura se rige por seguir la sintaxis \texttt{loop-for-count}, , y se construiría de la
siguiente forma:

\texttt{(loop-for-count   (<var>  <inicio>   <final>)  [do]   <acción>)}


Dónde:

\begin{itemize}
 \item \texttt{<var>}:  Variable que se usara como índice.
\item \texttt{<inicio>}:  Valor inicial que tendrá \texttt{<var>}
\item \texttt{<final>}:  Ultimo valor que tendrá la variable \texttt{<var>}
\item \texttt{<acción>}: Acción que es realizará hasta que \texttt{<var>} tenga el valor de \texttt{<fin>}
\end{itemize}


\end{enumerate}


\subsection{Formas de elegir una opción}

En este apartado explicaremos como crear una estructura \texttt{if} y una estructura
 \texttt{switch}.
\begin{itemize}
 \item \texttt{If}: Este tipo de estructura se rige por seguir la sintaxis
i\texttt{f -
then - else}, y se construiría de la siguiente forma:

\texttt{(if    <expresión>     then     <acción>     [else    <acción2>])}

	Dónde dependiendo del valor de  <expresión>:

\begin{itemize}
\item Valor  TRUE: Se realizará la acción \texttt{<acción>}.
\item Valor FALSE: Se realizará la acción \texttt{<acción2>} (en caso de haber)
\end{itemize}

\item \texttt{Switch}: Este tipo de estructura se rige por seguir la sintaxis
\texttt{switch - opciones}, y se construiría de la siguiente forma:

\begin{verbatim}
(switch   <expresión-test>
 (case OPCION1   then   ACCION1)
 (case OPCION2   then   ACCION2)
            .
            .
            .
 ([default]   ACCION-DEFAULT)
)
\end{verbatim}

Dónde dependiendo del valor de \texttt{<expresión-case>} se ejecutará una  \texttt{<acción>} en particular. Si ninguna \texttt{<opción>} es correcta, se ejecutara la \texttt{<acción-default>}.
\end{itemize}



\subsection{Funciones con la clase String}

	Habitualmente trabajaremos con Strings o cadena de Strings. CLIPS
proporciona una serie de herramientas para trabajar con esta clase:
\begin{enumerate}
 \item Convertir string a MAYÚSCULAS: A veces es conveniente tener todos los
caracteres en mayúsculas para no tener problemas de comparaciones o simplemente
por convenio. Para ello, CLIPS dispone de la función \texttt{upcase}, la cual
convierte a mayúsculas un símbolo o string.

\texttt{(upcase  <expresión-simbólica-o-de-cadena>  )}

Ejemplos:

\texttt{(upcase ``Clips es divertido'')}  $\rightarrow$ \texttt{``CLIPS ES
DIVERTIDO''}

\texttt{(upcase  Clips\_es\_divertido) } $\rightarrow$ 
\texttt{CLIPS\_ES\_DIVERTIDO}

\item Convertir string a MINÚSCULAS: la función es \texttt{downcase}.

\item Concatenación de strings: También es de gran utilidad poder juntar dos o
más parámetros  en un solo string.  Todo parámetro a juntar deben ser de uno de
los siguientes tipos: symbol. String, integer, float o instance-name.

\texttt{(str-cat      parametro1     parametro2     ...     parametroN  )}

Ejemplo:

\texttt{(str-cat "IA"{} nota 10)}  $\rightarrow$  \texttt{"IAnota10"}

\item Comparación de strings:  Función que nos indica si dos strings son
iguales.

\begin{verbatim}
(str-compare
      <expresión-simbólica-o-de-cadena> 
      <expresión-simbólica-o-de-cadena>
)\end{verbatim} 

Esta función devuelve:
\begin{description}
 \item 0:   Si ambos strings son iguales.
\item 1:   Si el primer string es mayor que el segundo string. 
\item -1: Si  el primer string es menor que el segundo string.

 \end{description}

\item Longitud de un string: Muchas veces es de gran utilidad saber que tamaño
tiene un string.:

\texttt{(str-length    <expresión-simbólica-o-de-cadena>)}

Ejemplo:

\texttt{(str-length "Inteligencia Artificial")}  $\rightarrow$ \texttt{23}

\end{enumerate}

\subsection{¿Cómo obtener el contenido de una variable en un string?}

Para conseguir un string a partir de un integer, float, symbol, instance-name, ... debes utilizar el comando \texttt{str-cat}. Si a la función le pasamos como parámetros varios elementos, los transformará a string y los concatenará. La sintaxis de esta función es la siguiente: \texttt{(str-cat elemento/s)}.
Esta función la usaremos sobre todo cuando queramos realizar comparaciones entre el contenido de una variable y un string ya que previamente, necesitaremos usar la función \texttt{str-cat} para pasar el contenido de la variable a string y realizar de este modo la comparación de forma correcta.


\subsection{¿Como se crea una lista?}

Con \texttt{create\$}. Todos los operadores sobre listas llevan el símbolo \$ al
final. Igual que con las variables se debe usar bind siempre que se desee
modificar una lista.
\medskip

\texttt{(bind ?lista (create\$ a b c))}

\subsection{¿Como borro un elemento de una lista?}

Con \texttt{delete\$}.Usa la siguiente sintaxis: 

\texttt{(delete\$ <lista>\ 
<indice-inicio>\  <indice-final>)}. 

Se borrarán todos los elementos del rango
entre las posiciones inicio y final, ambas incluidas. También existe\break
\texttt{delete-member\$}: \texttt{(delete-member\$ <lista> \  <elemento>)}.
Borrará todas las apariciones del elemento en la lista.
\medskip

\texttt{(delete\$ (create\$ a b c d e f) 3 5)} $\longrightarrow$
 \texttt{(a b f)}

\subsection{¿Como inserto elementos en una lista?}

Con\texttt{ insert\$}. Sintaxis: 

\texttt{(insert\$ <lista> <indice> <expresión
simple o
lista>)}.

Inserta todos los valores simples o de multicampo en la lista antes del
índice-ésimo valor (\texttt{<índice>} debe ser un entero) de la lista dada.
\medskip

\texttt{(insert\$ (create\$ a b c d) 1 x)} $\longrightarrow$ 
 \texttt{(x a b c d)}

\subsection{¿Como modifico elementos de una lista?}


Con \texttt{replace\$}. Sintaxis: 

\texttt{(replace\$ <lista-a-modifcar>\
<inicio>\ <final>\ <lista-nuevos-valores>)}. 

Los valores entre las posiciones
inicio y final serán
substituidos por la nueva lista. 
Recordar que el uso de bind es imprescindible  si queremos conservar los
cambios.
\medskip

\texttt{(replace\$ (create\$ a b c) 3 3 x)}$\longrightarrow$
 \texttt{(a b x)}

 \subsection{¿Como averiguo el número de elementos de una lista?}


Con \texttt{length\$}. Sintaxis \texttt{(length\$ <lista>)}.

\subsection{¿Como consulto un valor de la lista a través de su posición?}

A través de \texttt{nth\$}. Sintaxis: \texttt{(nth\$ <índice> <lista>)}.

\subsection{Como recorro todos los elementos de una lista?}


Manualmente con un bucle y \texttt{nth\$}, o con \texttt{progn\$}.
Sintaxis:\texttt{(progn\$ (<var> <lista>))}. La variable iterará sobre todos los
valores de la lista ordenadamente.

\begin{verbatim}
(progn$ (?var (create$ abc def ghi))
(printout t "-->" ?var "<--" crlf))
--> abc <--
--> def <--
--> ghi <--
\end{verbatim} 


\subsection{Com trobar si un element forma part d'una llista?}


Per comprovar que un element formi part de la llista (seguint l'exemple
anterior, com saber si un ingredient forma part de la llista d'ingredients)
podem fer servir \texttt{(member <ELEMENT> <LLISTA>)}, el qual retorna un booleà
indicant si l'element pertany a la llista o no.


\subsection{Tinc un conjunt de símbols, però estan tots junts en un string. ¿Com
ho faig per
separar-los i posar-los en un multislot?}

Has d'utilitzar la funció explode\$ de CLIPS, amb la sintaxi següent:
\medskip

\texttt{(explode\$ string)}
\medskip

Per exemple, si tenim una data en un string i volem extreure el dia:
\medskip

\texttt{(bind ?dia (nth\$ 1 (explode\$ ?data)))}

\subsection{I si tinc un multislot i el vull transformar en un string?}

Has d'utilitzar la funció implode\$ de CLIPS, amb la sintaxi següent:
\medskip

\texttt{(implode\$ multislot)}
\medskip

Per exemple, si volem crear un string que conté una data:
\medskip

\texttt{(bind ?data (implode\$ (create\$ 12 1 2008)))}


\subsection{¿Cómo obtener un valor aleatorio?}

Es probable que en algunos casos necesitemos obtener un valor aleatorio para realizar algún tipo de acción. CLIPS nos ofrece esta posibilidad mediante la función random, que retorna un número entero aleatorio:
\medskip

\texttt{(bind ?rand (random)).}

\subsection{Comparaciones}

Para comparar dos elementos: \texttt{(operador elemento1 elemento2)}. Siendo
operador \texttt{eq}, \texttt{<}, \texttt{=}, \texttt{>}, ...
Por ejemplo:
\medskip

\texttt{(eq ?nuevo TRUE)}

\texttt{(< ?precio ?saldo)}
\medskip

Un caso específico es la igualdad ya que varía en función del tipo de los
elementos comparados. Si se trata de un número se utilizará el operador
\texttt{=}, en caso de que los elementos sean objetos o símbolos \texttt{eq}.
Finalmente si estamos tratando cadenas debemos utilizar la función
\texttt{str-compare}. Esta devuelve un número entero que representa el resultado
de la comparación: 0 (son idénticos), 1 (elemento1 $>$ elemento2) o -1
(elemento1 $<$ elemento2).

De esta forma, si por ejemplo queremos comparar si dos cadenas son iguales, la
condición sería:
\medskip

\texttt{(= (str-compare "verano" "verano") 0)}



\section{Los módulos}

\subsection{Què és un mòdul en CLIPS?}


Els mòduls en clips són el mecanisme que ens proporciona aquest per tal de dividir, organitzar i, en alguns casos, fer més eficient, la execució de les nostres bases de coneixement. Ens poden ser útils, per exemple, per dividir un problema en diversos subproblemes, com per exemple, per dividir un problema en un primer subproblema d'anàlisis i un segon de construcció de la solució.

Els mòduls es defineixen de la següent manera:
\medskip

\texttt{(defmodule <nom-mòdul>)}
\medskip

Un mòdul només pot ser definit un cop, i no podrà ser tornat a definir mai, a excepció del mòdul
\texttt{MAIN}, que es pot redefinir tan sols un cop. Cal tenir en compte que cada mòdul té la seva
pròpia agenda.

\subsection{Partición en modulos}

Para que el sistema experto sea mucho más sencillo de actualizar y de
comprender, es muy aconsejable hacer una partición en módulos. Lo que hacemos
con esto es agrupar las reglas que busquen un objetivo en común. La construcción
de un módulo se hace poniendo \texttt{(defmodule nombre\_del\_modulo "La
descripción del módulo"  (import ...) (export ...))}. Un módulo termina en
donde empieza otro módulo, así que no hay que cerrar declaración, sino que se
hace implicitamente. En los apartados de import deberemos de poner todos
aquellos módulos de los cuales queramos obtener y usar sus reglas. Los export
son para indicar a los demás módulos que se puede usar de si mismo. Definir los
módulos si luego no se puede navegar por ellos no sirve para nada. Para eso está
el comando focus, el cual, seguido de un nombre de módulo, sirve para
especificar que el sistema va a estar centrado, focalizado, en el módulo
especificado. El uso de focus es muy adecuado como consecuente de una regla, por
ejemplo:

\begin{verbatim}
(defrule cambio-modulo-estilo-menu
  (Evento nombre_reserva ok)
  (Evento numero_comensales ok)
  (Evento temporada ?)
  (Evento presupuesto ok)
 =>
  (focus preguntas-estilo-menu)
)
\end{verbatim}

Cuando una regla no está en ningún módulo, es decir, el usuario no la ha incluido en ningun módulo, decimos que está en el módulo MAIN.


\subsection{¿Cómo asignar una construcción en un módulo?}

Existen dos formas para incluir una construcción en un módulo:
\begin{description}
 \item[Explícita:]
 se escribe el nombre del módulo (que es un símbolo) seguido de dos puntos(\texttt{::}), que
 representan el símbolo separador de módulos, y a continuación el nombre. Ej.
 (\texttt{MÓDULO::construcción})

\item [Implícita:] sin especificar el nombre del módulo ni los dos puntos \texttt{::}, ya que siempre existe un módulo ``actual''. El módulo actual cambia siempre que:
\begin{itemize}
 \item se defina una construcción defmodule
\item se especifica el nombre de un módulo en una construcción (usando \texttt{::})
\item se utilice la función s\texttt{et-current-module <nombre-módulo>}.
\end{itemize}
\end{description}

\subsection{Com funcionen les clàusules \texttt{export} i \texttt{import}?}


Abans de res, cal advertir que només es poden exportar i importar: \texttt{deftemplate}, \texttt{defclass}, \texttt{defglobal}, \texttt{deffunction} i \texttt{defgeneric}.

Hi ha 3 maneres d'exportar o importar construccions:
\begin{enumerate}
 \item Exportant/important el conjunt global de totes les construccions d'un mòdul

\begin{verbatim}
(defmodule modulA (export ?ALL) )
(defmodule modulB (import modulA ?ALL) )
\end{verbatim}
\item Exportant/important totes les construccions d'un mòdul que són d'un tipus particular

\begin{verbatim}
(defmodule modulA (export deftemplate ?ALL) )
(defmodule modulB (import modulA deftemplate ?ALL) )
\end{verbatim}
\item Exportant/important construccions específiques

\begin{verbatim}
(defmodule modulA (export deffunction funcio-util-1 funcio-util-2) )
(defmodule modulB (import modulA deffunction funcio-util-1 funcio-util-2) )
\end{verbatim}
\end{enumerate}


Per poder importar construccions d'un altre mòdul, és un requisit que aquest mòdul estigui definit abans del mòdul on estem definint la importació i que el mòdul estigui exportant les consrtuccions que voldrem usar en el nou mòdul.

Exemple:

\begin{verbatim}
(defmodule modulA (export deffunction funcioAdeu)) 
; exportem només la funció funcioAdeu

(deffunction modulA::funcioAdeu ()
 (printout t "Bye from ModuleA!" crlf)
)

(defmodule MAIN (import modulA ?ALL)) 
;importem totes les construccions de modulA

(defrule MAIN::inicio
     (initial-fact)
     =>
     (printout t "Hello from MAIN module!" crlf)
     (funcioAdeu)
)
\end{verbatim}
Si executem aquest codi obtindrem la següent sortida:

\begin{verbatim}
CLIPS> (run)
Hello from MAIN module!
Bye from ModuleA!
CLIPS>
\end{verbatim}




\subsection{¿Cómo cambio el módulo actual?}

El módulo \texttt{MAIN} es definido automáticamente por CLIPS y es el módulo actual por defecto
cuando se inicia por primera vez o después de un comando clear. Cada módulo tiene su propia agenda
(conjunto conflicto). Entonces la ejecución puede controlarse seleccionando una agenda, y en ésta se
elegirán reglas para ejecutar. Se puede cambiar el módulo actual mediante el comando focus:
\medskip

Sintaxis: \texttt{(focus <nombre-módulo>+)}
\medskip

CLIPS mantiene una pila de focos, y cada vez que se hace un cambio de módulo se añade el foco actual en el top de la pila. La ejecución de las reglas continúa hasta que cambia el foco a otro módulo, no haya reglas en la agenda, ó se ejecute return en la RHS de una regla.

En las reglas existe la propiedad auto-focus, que permite ejecutar automáticamente un comando focus cuando la regla se activa:
\medskip

Sintaxis: \texttt{(auto-focus TRUE | FALSE)}

\subsection{¿Como debería utilizar las focos en la practica de CLIPS?}

La manera más natural de organizar los módulos en la práctica de clips es de
manera lineal y con un  orden de ejecución consecutiva. Esto quiere decir, que
si nuestra práctica tiene 5 módulos estarán escritos de manera lineal m1, m2,
m3, m4 y m5 y querremos que se ejecuten de manera consecutiva : Primero m1,
después m2 así consecutivamente hasta llegar a m5.
De esto se deduce que al final de cada módulo, colocaremos un foco que nos
redirija al siguiente módulo. 

La redirección o salto al siguiente módulo puede ser de dos tipos :
\begin{enumerate}
 \item Incondicional: 

Queremos que independiente de que reglas se hayan cumplido el foco nos
redireccione al siguiente modulo. En este caso será suficiente con la sentencia

\texttt{(focus modulo-siguiente)}

\item Condicional:
Lo más habitual es queramos saltar al siguiente módulo solo si se han cumplido
una serie de reglas. La solución en este caso es incorporar el foco en la parte
derecha de la regla:

\begin{verbatim}
(defrule saltar-siguiente-modulo
 (declare (salience 0))
 (r1 ?)
 (r2 ?)
 (r3 ?)
 (r4 ?)
 (r5 ?)
 ->
 (focus modulo-siguiente)
)
\end{verbatim} \end{enumerate}

Como podrá apreciar el lector se ha incluido una  sentencia condicional en la
parte izquierda es: \texttt{(declare (salience 0))}. Mediante esta instrucción
podemos asignar una prioridad en el orden de ejecución a la regla. 
  En este caso se
ha asignado prioridad 0, suponiendo que todas las reglas restantes del módulo
tienen una prioridad más alta (por ejemplo 10), asegurándonos que será la última
en ejecutarse.


\section{Funciones}



\subsection{¿Cómo se crea una función en CLIPS?}

Una deffunction se compone de cinco elementos:
\begin{enumerate}
 \item Un nombre, que debe ser un símbolo.
\item Un comentario, que es opcional.
\item Una lista de cero o más parámetros requeridos, que deben ser variables
simples)
\item Un parámetro comodín opcional que sirve para manejar un número variable
de
argumentos.
\item Una secuencia de acciones o expresiones que serán ejecutadas en orden
cuando
se llame a la función.
\end{enumerate}



\begin{verbatim}
(deffunction
     <nombre>                  (1)
     [<comentario>]            (2)
     (<parámetro>*             (3)
     [<parámetro-comodín>])    (4)
     <acción>*                 (5)
)
\end{verbatim}

El valor devuelto por la función es la última acción o expresión evaluada dentro
de la función.  Si una deffunction no tiene acciones, devolverá el símbolo
\texttt{FALSE}. Si se produce algún error mientras se ejecuta la función,
cualquier otra acción de la función aún no ejecutada se abortará, y la función
devolverá el símbolo \texttt{FALSE}.

Ejemplo:

\begin{verbatim}
(deffunction
   mostrar-params                                Nombre (1)
   (?a ?b                                        Parámetro  simples (3)
   $?c)                                          Parámetro múltiple  (4)
   (printout t ?a " " ?b " and " (length ?c)
                         " extras: " ?c crlf)    Acción (5)
)\end{verbatim}

La función anterior guarda los dos primeros parámetros dentro de las variables
\texttt{?a} y \texttt{?b} y el resto (en caso de haber) en \texttt{\$?c}. Esta función realiza la
acción de imprimir por pantalla un mensaje formado por:

    Los valores de las variables \texttt{a} y \texttt{b}  +  and + longitud de la variable
\texttt{c} + extras + valores de \texttt{c}

Si  ejecutamos la función definida anteriormente con dos parámetros:
\texttt{(mostrar-params 1 2)} el valor de cada variable será:
\begin{description}
 \item[?a]= 1
\item[?b]= 2
\item [?c]= Vacio
 \end{description}



E imprimirá: \texttt{1 2 and 0 extras: ()}

Si  ejecutamos la función definida anteriormente con cuatro parámetros:
(mostrar-par a b c d) el valor de cada variable será:

\begin{description}
 \item[?a]= a
\item[?b]= b
\item [?c]= c d
 \end{description}

E imprimirá: \texttt{1 2 and 2 extras: (c d)}

\subsection{Explicación de la estructura de una función en general.}

Hacer una función en CLIPS es igual que en cualquier otro lenguaje. Se ha de
tener en cuenta que la función no tiene activadores como en una regla.
Únicamente, ésta tiene que ser colocada dentro del módulo donde va a ser
utilizada y siempre tiene que devolver algo (tal como se verá en el ejemplo de
estructura siguiente).
Ejemplo:

Si en pseudocódigo tuviésemos:

\begin{verbatim}
funcion devuelvo_boolean (lista L1, lista L2)
{
 boolean b = false;
 int i = 1;
 mientras(i<=N && !b)
 {
  ...
  i++;
  }
 return b;
}
\end{verbatim}

En CLIPS quedaria así:
\begin{verbatim}
(deffunction devuelvo_boolean (?L1 ?L2)
  (bind ?b FALSE)
  (bind ?i 1)
  (while (and (<= ?i  N) (not ?b))
    do
    ...
    (bind ?i (+ ?i 1))
  )
 ?b
)
\end{verbatim}

\subsection{Com definir un paràmetre d'una funció com una llista?}


Si volem que un paràmetre de la funció sigui una llista, ho haurem d'indicar amb un \texttt{\$}. Per
exemple,

\begin{verbatim}
(deffunction pertany (?var $?llista) (member ?var ?llista))
\end{verbatim}

Retornaria si var forma part d'una llista.

La manera d'indicar que un paràmetre és una llista seria la mateixa per els fets
a la part esquerre d'una regla.


\subsection{Com puc utilitzar una funció a la part esquerra de les regles?}

Fent servir la instrucció \texttt{test}.
test es satisfà si la funció retorna qualsevol valor diferent de FALSE
\medskip

\texttt{(test (estaALaLlista ?persona1 \$?personesConvidades ))}


\section{Entrada salida}

\subsection{¿Cómo se imprime por pantalla?}

	Para imprimir por pantalla sin especificar el formato de cada parámetro
se usa la función \texttt{printout}.

\texttt{(   printout  nombre-logico  <parámetro>+  )}


\begin{itemize}
 \item \textbf{Nombre-lógico:} Envía al dispositivo asociado con el nombre
lógico especificado
un string formateado. Puede tener uno de los siguientes valores:
\begin{itemize}
 \item \textbf{Nil:} No se produce salida pero devuelve el string formateado.
\item \textbf{T:} Se imprime en la salida estándar.
\end{itemize}
\item\textbf{ Parámetros:} Los parámetros pueden ser:
\begin{itemize}
 \item \textbf{Variables:}  Si queremos imprimir el valor de una variable
debemos escribir un
interrogante y su nombre:  \texttt{?nombreVariable}
\item \textbf{Resultado de funciones:}  Si queremos escribir el valor de retorno
de una función
deberemos escribir entre paréntesis la función a ejecutar:
\texttt{(nombreFuncion)}
\item \textbf{Strings:} Si queremos escribir una cadena des Strings, deberemos
poner la cadena
de strings entre comillas: \texttt{"loQueQuieraEscribir"}.
\end{itemize}




\end{itemize}




Si por el contrario queremos especificar el tipo de cada parámetro a imprimir,
usaremos la función \texttt{format}.

\texttt{(   format    <nombre-logico>     <string-control>     <parámetros>*
)}

\begin{itemize}
 \item \textbf{Nombre-lógico:} Envía al dispositivo asociado con el nombre
lógico especificado
un string formateado. Puede tener uno de los siguientes valores:
\begin{itemize}
 \item \textbf{Nil:} No se produce salida pero devuelve el string formateado.
\item \textbf{T:} Se imprime en la salida estándar.
\end{itemize}


\item \textbf{String-Control:} El string de control contiene unos flags de
formato que indican
cómo serán impresos los parámetros.  Estos flags son de la forma :
\texttt{\%[-][M][.N]x},
donde:
\begin{itemize}
 \item -: Es opcional y significa justificado a la izquierda (por defecto
derecha).
\item M: Indica la anchura del campo en columnas. Como mínimo se imprimirán M
caracteres.
\item N: Específica el numero de dígitos a la derecha del punto decimal y es
opcional.
Por defecto se toman 6 para los números reales.
\item X: Especifica el formato de impresión y puede ser:
\begin{itemize}
 \item d: Entero
\item f:  Decimal
\item e: Exponencial (potencias de 10).
\item g: General (numérico). Imprimir con el formato mas corto.
\item o: Octal. Numero sin signo. (N no se aplica)
\item x: Hexadecimal.
\item S: String.
\item N: Salto de línea.
\item R: Retorno de carro.
\item \%: el carácter ``\%''.
\end{itemize}

\end{itemize}


\item \texttt{Parámetros:} Parámetros a imprimir.

\end{itemize}

\subsection{¿Al imprimir por pantalla como hago un salto de línea?}

Con \texttt{crlf}.

\subsection{Com imprimeixo una línia en blanc?}

Sense escriure cap text:
\medskip

\texttt{(printout t crlf)}




\subsection{Com llegir de la entrada standard?}


Per llegir de l'entrada estàndard CLIPS ofereix el mètode \texttt{(read)}.
Generalment, per llegir el que vol entrar un usuari farem:
\medskip

\texttt{(bind ?text (read))}
\medskip

Això deixarà a la variable \texttt{?text} el que escrigui l'usuari fins que faci
un retorn de carro.

Si volem comprovar que la resposta sigui un String podem fer
servir, \texttt{(lexemep
<VALOR>)} el qual comprova que \texttt{VALOR} sigui  un String o un Symbol.

Si el que volem és un enter, podem fer servir \texttt{(integerp <VALOR>)}, que
comprova que VALOR sigui un enter.


\subsection{Vull llegir un número (o conjunt de números) com un string, però
CLIPS me'ls
llegeix com un enter}

Utilitza la funció \texttt{(readline)} en lloc de la funció \texttt{(read)}.
\medskip

{\bf nota adicional:} Las funciones \texttt{(read)} y \texttt{(readline)} tienen un comportamiento
diferente. La función \texttt{(read)} espera un elemento válido de CLIPS en la entrada (un entero,
un real, un string, un símbolo, una instancia, incluso una lista) e ignora todo lo que queda en la
entrada una vez ha reconocido el elemento válido. Este comportamiento es habitual en muchos
lenguajes de programación no imperativos (funcionales y declarativos) como por ejemplo LISP o Prolog
donde los procedimientos de lectura no se limitan a reconocer caracteres, sino que son conscientes
de las estructuras del lenguaje. La función \texttt{(readline)} es la función de tratamiento de
lectura de caracteres habitual en los lenguajes imperativos.

\subsection{Haig de fer una pregunta a l'usuari, i la resposta és un conjunt d'elements (no sé d'entrada quants), com ho faig per assignar-los a un multislot?}

Per fer això primer necessites definir una funció que llegeixi un string d'entrada (que contindrà el conjunt d'elements) i després trencar la cadena per poder distingir cada element individualment (``pasta marisc fruita'' $->$ ``pasta'' ``marisc'' ``fruita''). A l'exemple següent es veu com fer-ho:

\begin{verbatim}
; Fa una pregunta sobre una llista d'elements
(deffunction pregunta-llista (?pregunta) 
  (format t "¿%s?" ?pregunta)
  ; Llegim una línea sencera (Ex. ``Pasta Marisc Fruita'')
  (bind ?resposta (readline)) 
  ; Separem l'string (Ex. ``Pasta'' ``Marisc'' ``Fruita'')
  (bind ?res (str-explode ?resposta)) 
  ; Retornem els diferents camps (Ex. ``Pasta'' ``Marisc'' ``Fruita'')
  ?res
) \end{verbatim}


Un cop tenim la funció, l'únic que hem de fer és assignar els valors que hem llegit i processat a la variable que ens interessi. Per exemple, suposem que volem assignar la resposta a una variable anomenada ingredients:
\medskip

\noindent \texttt{(bind ?ingredients\break (pregunta-llista "Hi ha algun ingredient que no desitgi
incloure al menu"))
}





\section{Funciones útiles}


\subsection{Obtener una respuesta de un conjunto predefinido de respuestas posibles}

\begin{verbatim}
(deffunction   pregunta  (?pregunta  $?valores-permitidos)
      (progn$
        (?var ?valores-permitidos)
        (lowcase ?var))
      (format t "¿%s? (%s) " ?pregunta (implode$ ?valores-permitidos))
      (bind ?respuesta (read))
      (while (not (member (lowcase ?respuesta) ?valores-permitidos)) do
        (format t "¿%s? (%s) " ?pregunta (implode$ ?valores-permitidos))
        (bind ?respuesta (read))
      )
   ?respuesta
)
\end{verbatim}

Esta función guarda en el parámetro \texttt{respuesta} la respuesta elegida. La función es muy simple:
\begin{enumerate}
\item Convierte a minúsculas el conjunto de valores permitidos para prevenir errores de comparación.
\item Lee de teclado y guarda la respuesta en la variable \texttt{respuesta}
\item Mientras la respuesta no sea una de las permitidas sigue haciendo la pregunta.
\item Devuelve la respuesta correcta.
\end{enumerate}


\subsection{Obtener un valor numérico comprendido en un rango}

\begin{verbatim}
(deffunction   pregunta-numerica (?pregunta ?rangini ?rangfi)
 (format t "¿%s? [%d, %d] " ?pregunta ?rangini ?rangfi)
 (bind ?respuesta (read))
 (while (not(and(> ?respuesta ?rangini)(< ?respuesta ?rangfi))) do
        (format t "¿%s? [%d, %d] " ?pregunta ?rangini ?rangfi)
        (bind ?respuesta (read))
 )
 ?respuesta
) \end{verbatim}

Esta función guarda en el parámetro \texttt{respuesta} el valor elegido. La función es muy simple:

\begin{enumerate}
 \item Lee de teclado y guarda la respuesta en la variable \texttt{respuesta}
\item Mientras el valor no este contenido dentro del rango deseado sigue haciendo la pregunta.
\item Devuelve la respuesta correcta.
\end{enumerate}


\subsection{Realizar una pregunta general}


\begin{verbatim}
(deffunction   pregunta-general  (?pregunta)
  (format t "¿%s?" ?pregunta)
  (bind ?respuesta (read))
  ?respuesta
)\end{verbatim}

Realiza una pregunta y almacena la respuesta en \texttt{respuesta}

\subsection{¿Cómo se realiza una pregunta binaria?}


\begin{verbatim}
(deffunction si-o-no-p (?pregunta)
    (bind ?respuesta (pregunta ?pregunta si no s n))
    (if (or (eq (lowcase ?respuesta) si) (eq (lowcase ?respuesta) s))
        then TRUE
        else FALSE
    )
) \end{verbatim}

Devuelve cierto si se escribe \texttt{s} o \texttt{si} y falso en caso contrario.

\subsection{Encuentra la instancia con valor mínimo para un slot }

\begin{itemize}
\item  El primer parámetro es la lista de instancia.
\item El segundo parámetro es el método con el que se accede al slot.
\item El tercer parámetro es el valor con que se inicializa la instancia.
\end{itemize}


Devuelve FALSE si no encuentra ninguno o si la lista está vacía.


\begin{verbatim}
(deffunction minimum-slot (?li ?sl ?init)
 (bind ?encontrado FALSE)
 (if (neq ?li FALSE) then
 (bind ?li (create$ ?li))

  (if (> (length ?li) 0) then

   (bind ?min ?init)
   (loop-for-count (?i 1 (length ?li))

    (bind ?v (send (nth$ ?i ?li) ?sl))

    (if (< ?v ?min) then

     (bind ?encontrado TRUE)
     (bind ?min ?v)
     (bind ?ins (nth$ ?i ?li))

    )
   )
  )
 )
 (if (eq ?encontrado FALSE) then
  (bind ?ins FALSE)
 )
 (return ?ins)
)
\end{verbatim}

\subsection{Elimina de la lista de instancias aquellas que por el multislot sl no contengan valor const}

\begin{itemize}
 \item El primer parámetro es la lista de instancia.
\item  El segundo parámetro es el método con el que se accede al slot.
\item  El tercer parámetro es el valor con que se inicializa la instancia.
\end{itemize}

Devuelve FALSE si no encuentra ninguno o si la lista esta vacía.


\begin{verbatim}
(deffunction filtrar-multi-por (?li ?sl ?const)

 (bind ?encontrado FALSE)
 (if (neq ?li FALSE) then

  (bind ?li (create$ ?li))

  (if (> (length ?li) 0) then
   (loop-for-count (?i 1 (length ?li))
    (bind $?v (send (nth$ ?i ?li) ?sl))
    (if (member$ ?const $?v) then
     (if (eq ?encontrado FALSE) then
      (bind ?encontrado TRUE)
      (bind ?ins (nth$ ?i ?li))
     else
      (bind ?ins (create$ ?ins (nth$ ?i ?li)))
     )
    )
   )
  )
 )
 (if (eq ?encontrado FALSE) then
  (bind ?ins FALSE)
 )
 (return ?ins)
)
\end{verbatim}

\subsection{Random slot. Devuelve una instancia aleatoria de entre las que hay en la lista li.}

\begin{verbatim}
(deffunction random-slot ( ?li )
 (bind ?li (create$ ?li))
 (bind ?max (length ?li))
 (bind ?r (random 1 ?max))
 (bind ?ins  (nth$ ?r ?li))
 (return ?ins)
)
\end{verbatim}

\subsection{Recorre todos los elementos del slot que recibe por parámetro y los imprime por pantalla}



\begin{verbatim}
(deffunction imprime-todo (?v)
  (if (> (length$ ?v) 0) then
   (loop-for-count (?i 1 (length ?v))
     (send (nth$ ?i ?v) print)
     (printout t crlf)
   )
 )
)\end{verbatim}



\section{Ejecución de un programa CLIPS}

\subsection{¿Cómo cargamos un programa?}

Para programar en CLIPS utilizaremos ficheros con extensión CLP que contendrán
el conjunto de instrucciones ha ejecutar.
\subsubsection*{Entorno Windows / Mac OS X}
\begin{description}
 \item[Cargar por comandos:] Debemos escribir   \texttt{(load
"PATH/nombrefichero.clp")}
\item [Cargar por entorno grafico:] Debemos ir al menú -$>$ load -$>$
seleccionar el
fichero.
 \end{description}


\subsubsection*{Entorno Linux}
\begin{description}
 \item[Cargar por comandos:] Debemos escribir  (load ``PATH/nombrefichero.clp'')
 \end{description}


\subsection{¿Cómo probar tu código en CLIPS?}

Tienes que abrir
la aplicación CLIPS y escribir (clear) en el Dialog Window. Posteriormente,
necesitas cargar los ficheros clips. Si tienes la ontología y las reglas por
separado tendras que cargar primero el fichero con la ontología y despues el de
las reglas. Esto lo puedes hacer desde File->Load y seleccionando el fichero
\texttt{.clp} en cuestión. A continuación debes escribir (reset) en el Dialog
Window y ahora CLIPS ya estará preparado para ejecutar tu código. En concreto,
lo hará cuando escribas \texttt{(run)}.




\subsection{¿Qué es necesario hacer entre ejecución y ejecución?}

Una vez has acabado una ejecución de tu código, si por el motivo que sea quieres
realizar otra, es imprescindible que escribas (reset) en el Dialog Window ya que
así borras todas las reglas activadas y los hechos introducidos en la anterior
ejecución. A continuación, podrías empezar la ejecución con el comando (run).
Si al finalizar una ejecución, introduces algún cambio en el código y quieres
probarlo, debes seguir lo explicado en la pregunta ¿Cómo probar tu código en
CLIPS? pero sin tener que abrir el CLIPS de nuevo.

\subsection{¿Cómo parar una ejecución?}

Para detener la activación de reglas se usa el comando \texttt{(halt)}. La agenda permanece intacta, y la ejecución puede reanudarse con el comando \texttt{(run)}.
No devuelve ningún valor.

\subsection{¿Como vuelvo al estado inicial y qué contendrá éste?}

Con la función \texttt{reset}. Éste contendrá todos los hechos declarados con
\texttt{deffacts}, las instancias de definstances y las reglas (empezando desde
cero obviamente).

\chapter{Consejos prácticos}

\section{Tinc el disseny de la pràctica fet, però a l'hora d'implementar tot
això no sé
ni per on començar! Algun consell?}

Bé, tothom té formes de treballar diferents, però un bon sistema pot ser el
següent:

Comença amb una ontologia molt reduïda, que tingui un parell de classes i molt
poques instàncies a cada classe (per poder provar coses).
Després fes funcions i/o regles senzilles amb CLIPS que et permetin obtenir
informació de l'ontologia que has creat. Pots començar amb regles que et
retornin totes les instàncies d'una determinada classe. Segurament això al
principi també et pot ser confós, aquí tens un exemple molt bàsic:

\begin{verbatim}
(defrule retorna_instancies
   (not retorna_instancies ok)
    =>
   (bind ?llista_instancies (find-all-instances ((?instancia Nom_Classe)) TRUE)
   (assert retorna_instancies ok)
)
\end{verbatim}

Un cop tinguis una regla que funciona i que saps com funciona, es tracta
d'anar-hi afegint coses a poc a poc (tant a les regles com a l'ontologia). Com
ara canviant el \texttt{TRUE} de l'exemple anterior per alguna condició de
l'estil

\begin{verbatim}
  (eq ?instancia:nom nom_de_la_instancia_que_vull)
\end{verbatim}


\section{¿Como estructuro una practica de CLIPS?}

A continuación se presenta una propuesta de estructura, para facilitar el comienzo de la misma.
El diseño esta sacado de la práctica  MIKEO cedida por EVA Pallarés.

\begin{enumerate}
 \item Definición de las clases

Aquí deberíamos hacer un \textit{ cortar y pegar} de todo el contenido de fichero \texttt{.pont}

\item  Instancias

Aquí deberíamos hacer un \textit{ cortar y pegar} de todo el contenido de fichero \texttt{.pins}

\item  Exportación del MAIN

\texttt{(defmodule MAIN (export ?ALL))}

\item Templates

Incluimos posibles templeates que tengamos que utilizar.

\item  Mensajes

En esta parte incluiremos la comunicación (envió de mensajes) con las clases. Como habitualmente, en la práctica de CLIPS, la utilización de envío de mensajes  se suele utilizar para imprimir  el contenido de una clase, podríamos decir que aquí incluiremos el  código de impresión de clases.

\item  Funciones

 Aquí incluiremos todas las funciones que vayamos a utilizar.

\item  Reglas

 La parte de reglas, como hemos comentado anteriormente estarán agrupadas en módulos.
 La organización de los módulos depende mucho del programador y el problema a resolver.
 De todas formas, existen algunos módulos que se suelen repetir como:

\begin{enumerate}
 \item Módulos de preguntas.

 Será totalmente necesario obtener información sobre las preferencias y restricciones del usuario.

\item Módulo de selección

 Suele ser habitual hacer selección de instancias que cumplan las restricciones impuestas por el usuario.

\item Módulo de construcción

 Será necesario que nuestro SBC construya una solución a nuestro problema.

\item Módulo de impresión de resultados

 Necesitaremos un módulo final para imprimir la solución encontrada.
\end{enumerate}

\end{enumerate}


\section{Com crear un flux de preguntes?}


En la majoria de sistemes experts hi ha una primera fase de recopilació d'informació.

Aquesta recopilació es pot fer a través de preguntes a l'usuari. Aquestes preguntes poden tenir dependències entre elles: per exemple, si un client ens diu que té telèfon mòbil, procedirem a preguntar-li el número d'aquest mòbil, però si ens diu que no, no li preguntarem el número. Així, el fet que el client tingui mòbil és un prerequisit per preguntar-li quin és el número de telèfon del seu mòbil.

Per això usem el sistema de regles que ens proporciona CLIPS i introduirem aquest prerequisit a la part esquerra de la regla.

\begin{verbatim}
(defrule preguntar-numero-mobil
 (mobil si)
 =>
 (printout t "Quin és el teu número de mòbil?")
 (bind ?numero-mobil (read))
 (assert numero-mobil ?numero-mobil)
)
\end{verbatim}

D'aquesta manera, la regla \texttt{preguntar-numero-mobil} només s'activarà
si l'usuari ha contestat que sí a la pregunta ``tens mòbil?''.


\subsection{Com puc ordenar aquest flux de preguntes?}


Per altra banda, ens pot interessar fer que les preguntes que fem a l'usuari tinguin un cert ordre. Per exemple, ens pot interessar preguntar-li a l'usuari primer el seu nom, i posteriorment preguntar-li si té telèfon mòbil. En aquest cas la primera pregunta no és un prerequisit per preguntar la segona, però és de sentit comú que tinguin aquest ordre. Per traduir això a clips podem fer:

\begin{verbatim}
(defrule preguntar-mobil
 (nom ?nom-usuari)
 =>
 (
  if (yes-or-no-p "Tens telèfon mòbil?")
  then (assert (mobil si))
  else (assert (mobil no))
 )
)
\end{verbatim}

D'aquesta manera la pregunta sobre el mòbil només es dispararà quan l'usuari hagi contestat a la pregunta del seu nom.


\subsection{I si vull saltar-me una pregunta?}


En alguns casos ens podem trobar amb la situació de tenir una pregunta ja resolta implícitament en la resposta d'alguna pregunta prèvia. Per exemple, suposem que volem preguntar-li a una persona si vol prendre alguna beguda alcohòlica, però prèviament li hem preguntat la edat en aquesta persona. Podríem fer-ho de dues maneres.
\begin{enumerate}
 \item Com fins ara, amb:

\begin{verbatim}
(defrule preguntar-alcohol
 (edat major-edat)
 =>
 (
  if (yes-or-no-p "Vols prendre alguna beguda alcoholica?")
  then (assert (alcohol si))
  else (assert (alcohol no))
 )
)
\end{verbatim}
Aquesta solució funcionaria, però imaginem que també hem preguntat a l'usuari quina és la seva religió. Si l'usuari ha contestat ``religió musulmana'', aleshores tampoc li haurem de preguntar si vol prendre alcohol. Haurem d'afegir a la part esquerra de la regla una sentencia com:

 \texttt{(not (religio musulmana))}

com a prerequisit, i haurem de fer el mateix amb cadascun dels fets o motius que impliquin que la persona no pot beure alcohol.

\item Una altra manera és ``enganyar'' al sistema i fer-li creure que l'usuari ja ha respost la pregunta sobre l'alcohol actuant en el moment de preguntar per la religió. Així:


\begin{verbatim}
(defrule preguntar-religio
 =>
 (bind ?religio 
  (ask-question "Quina religió practiques?" catòlica musulmana budista cap))
 (if (eq ?religio "musulmana")
  then (assert (alcohol no)) (assert (porc no)))
)\end{verbatim}

I després:

\begin{verbatim}
(defrule preguntar-alcohol
 (not (alcohol ?si_o_no)
 =>
 ...
)\end{verbatim}

I ja posats també:

\begin{verbatim}
(defrule preguntar-porc
 (not (porc ?si_o_no))
 =>
 ...
)\end{verbatim}

D'aquesta manera aconseguim que el sistema no pregunti a l'usuari si vol prendre alcohol o si vol menjar porc, perquè en el moment de preguntar-li la religió hem tingut en compte aquests valors. A més, hem trobat una manera de implementar un flux de preguntes en el qual, alhora d'obtenir les respostes, no hem de modificar regles ``futures'' (dins del flux d'execució de preguntes).

\end{enumerate}

\subsection{Com inicialitzar el flux del programa?}


Per inicialitzar el flux d'execució tenim varies possibilitats.

Algunes d'elles són:
\begin{itemize}
\item Definir un fet per defecte (deffact) el qual faci saltar una regla inicial
per defecte (que podríem definir amb un salience alt).

Per exemple,

\begin{verbatim}
(deffacts tipus-usuari
  (us desconegut)
)
\end{verbatim}
Que faria saltar la regla inicial:

\begin{verbatim}
(defrule inici
(declare (salience 10))
?us <- (us desconegut)
=>
(printout t "Benvingut!" crlf)
....
)\end{verbatim}

\item Una regla inicial podria preguntar per si no existeix un fet que acabarà inicialitzant.

Per exemple,

\begin{verbatim}
(defrule inici
 (not (flor ?tipus))
=>
(printout t "Benvingut" crlf)
...
(assert (flor rosa))
)\end{verbatim}
\end{itemize}


\section{Uso de la función modify para ir guardando resultados preferidos}

Para empezar hemos de tener una plantilla que, en el caso de un sistema para escoger platos, sea donde coloquemos los platos que se van ajustando a nuestra. Esta seria su estructura:

\begin{verbatim}
(deftemplate platos-apropiados
   (slot estado)
   (multislot lista-platos1)
   (multislot lista-platos2)
   (multislot lista-postres)
)\end{verbatim}

Entonces cuando vayamos obteniendo resultados para ir guardandalos en los diferentes multislots, tendremos que llamar a la instancia de dicha plantilla desde los activadores de las reglas, usando como guía el slot estado.


	\texttt{?paprop <- (platos-apropiados (estado empezado))}

En este caso recuperariamos la instancia de \texttt{platos-apropiados} que ha sido inicializada en otra regla, pero mantendriamos la misma con los resultados ya guardados hasta el momento.
Si en esta regla quisieramos insertar datos en otro multslot de dicha instancia (por ejemplo \texttt{lista-platos2}) tendriamos el siguiente código:

	\texttt{(modify ?paprop (estado empezado)(lista-platos2 \$?lista2))}

Donde \texttt{lista2} seria el resultado de hacer un \texttt{find-all-instances} por ejemplo.

\section{Creación de la plantilla de recomendación}

Una vez aplicadas todas las reglas necesarias y manipulado todo el conocimiento que hayamos tenido que usar en el problema, deberemos mostrar los resultados al usuario. Para ello, si partimos de que hemos tenido que construir un resultado a partir de ciertas preferencias o restricciones, lo más adecuado es usar una plantilla para poner el resultado y tenerlo estructurado. En este caso, lo que se debe hacer es partir de una plantilla vacia, la cual se irá rellenando conforme calculemos los resultados. La plantilla será un deftemplate con los atributos que va a tener el resultado final y deberá estar en un ámbito visible para todos los módulos, para que así la puedan ir modificando y completando.

Ejemplo de plantilla de recomendación para menús de restaurante:

\begin{verbatim}
(deftemplate recomendacion "Recomendacion resultante del sistema experto"
  (slot evento)
  (multislot menus)
  (slot final?)
)\end{verbatim}

Donde el slot evento guardaria una instancia de la clase Evento que contendria las propiedades de la comida (número invitados, temporada, ...), el multislot menus tendria las instancias de los menús finales para proponer y el slot final? seria una guia para, una vez obtenidos los resultados, activar la regla para mostrar los resultados por pantalla

\chapter{Errores frecuentes}

\section{Quan obro un fitxer en CLIPS em dona un error!}


L'editor de text de l'entorn gràfic de CLIPS no accepta fitxers més grans de
65KB. Aquesta quantitat de bytes pot ser àmpliament superada quan introduïm una
gran quantitat d'instàncies a la base de coneixement mitjançant protégé i la
exportem a format CLIPS.

Per saltar aquest problema només hi ha una solució: carregar el fitxer
directament per línia de comandes, sense usar l'editor de text de CLIPS, amb la
comanda \texttt{(load <NOM\_FITXER>)}.

Per exemple:

\begin{verbatim}
(load fitxer.clp)
\end{verbatim} 
Per a continuació, fer:

\begin{verbatim}
(reset)
(run)
\end{verbatim} 


\section{Codificació de caràcters a CLIPS}


CLIPS dona força problemes amb caràcters estranys com ñ, accents, dièresis,
etc.

En principi no accepta Unicode ni \texttt{ISO-8859-1}, així que recomanem no fer
servir caràcters com els mencionats per tal de no tenir problemes. A més,
protégé exporta amb codificació \texttt{ISO-8859-15}. La majoria d'editors de
linux usen per defecte codificació \texttt{UTF-8}. Això és un problema, perquè
alhora d'editar un document podeu perdre alguns caràcters si no configureu la
codificació del vostre editor a I\texttt{SO-8859-15} i això provocarà que CLIPS
no reconegui el fitxer com a vàlid. Un editor de linux que permet canviar la
codificació de caràcters usada en un fitxer és \texttt{kwrite} (cal
configurar-ho abans de començar a modificar el fitxer).

Si al carregar un fitxer tenim problemes i no ho sabem identificar, és útil
comprovar si pot haver-hi algun caràcter que estigui creant aquests problemes.


\section{Què significa l'error OBJRTBLD5?}

A l'apèndix G de la ``CLIPS Basic Programming Guide'' trobaràs el significat de tots els errors que dóna CLIPS.





\section{Antes compilaba correctamente y ahora da warnings.}

\texttt{[CSTRCPSR1] WARNING: Redefining defrule: imprimir +j+j.}

Si aparecen warnings como este a la hora de compilar en todas las funciones, reglas, etc, que se han
definido en el código, es posible que no se haya hecho un \texttt{clear} antes de compilar
nuevamente.
Para ello usar la opción del menu  \textit{Execution} $\rightarrow$ \textit{Clear Clips}, o bien, en
la ventana de entrada de CLIPS escribir  \texttt{(clear)}.
Luego volvemos a cargar el fichero.

Este problema es debido a que los módulos no pueden ser ni redefinidos ni borrados una vez que se definen (con la excepción del módulo MAIN que puede ser redefinido una vez). La única forma de eliminar un módulo es con el comando clear.


\section{No puedo editar mi fichero en clips.}

Esto es debido a que el .clp ha llegado a su máxima extensión. Para solucionar el problema, debemos abrirlo con un editor de texto externo y proceder como siempre, es decir:

\begin{verbatim}
Execution -> Clear Clips
Execution -> Load (seguiremos cargando el .clp/.txt que 
                   hemos modificado y guardado previamente en el editor de texto).
Execution -> Reset
Execution -> Run
\end{verbatim}

\section{Redefining}

Este warning es debido en el mayor número de casos, a que existen dos o más reglas, funciones, ... que tienen el mismo nombre. Para solucionarlo, obviamente, cambiar el nombre de cada una de manera que no compartan nombres.

\section{Problemas al consultar las instancias relacionadas con otras}

Por alguna razón desconocida CLIPS solo busca instancias en el modulo actual y no en todos los importados.
La solución mas sencilla es añadir a todas las instancias de la ontología el cualificador del modulo principal. Si se substituye en el fichero de las instancias la cadena ``['' por ``[MAIN::'' estará todo solucionado.

Por ejemplo:
\medskip

\texttt{([pracIA\_Instance\_30001] of  Bebida $\rightarrow$ ([MAIN::pracIA\_Instance\_30001] of  Bebida}


\section{Unable to finde class X cuando definimos instancias}


\begin{verbatim}
Defining definstances: instancias
[PRNTUTIL1] Unable to find class Plato.

ERROR:
(definstances MAIN::instancias
 ([pracIA_Instance_1] of Plato\end{verbatim}

Si nos aparece algo parecido a esto cuando compilamos nuestro programa significa que no encuentra la
clase a la que pertenece la instancia. Es posible que hayamos definido primero las instancias y
luego las clases. Para corregirlo, seguir la estructura comentada en el fichero de CLIPS: ontología
+ instancias + código.

\section{Expected the beginning of a construct (cuando definimos instancias).}


Si nos aparece este error justo donde definimos las instancias, es posible que sea porque no hayamos seguido la correcta estructura para añadir instancias en nuestro código:
\texttt{(definstances cualquiernombre INSTANCIAS )}.


\section{Compila pero no compara bien dos elementos}

Posiblemente se trata de que estemos realizando la comparación de dos cadenas de caracteres con el operador eq. Existe una funcion especifica para comparar dos strings: str-compare explicada en el apartado de funciones.


\section{Expected the beginning of a constructor}


Aquest error sol ser molt freqüent i es pot donar per diversos motius.

\begin{enumerate}
 \item El primer i més freqüent és perquè hem posat un parèntesis tancat ``)'' de més. Surt quan, per exemple, tenim:

\texttt{(assert (processador AMD) ) ) ; <-- l'últim parèntesis sobra}

Haurem de repassar quin ha estat el codi que hem retocat que ens ha incorporat aquest error i trobar el parèntesis que sobra.
\item El segon motiu pel qual també es pot donar aquest error és perquè, per exemple, no hem encapsulat el codi de les instàncies generades automàticament mitjançant protégé dins la clau:

\begin{verbatim}
(definstances nominstancies
 <instàncies>
)
\end{verbatim}
En definitiva, el que aquest error ens està indicant és que CLIPS espera la construcció d'una regla/funció/acció/etc. i en comptes d'això es troba amb qualsevol altra cosa: un parèntesis tancat, una instància, etc.
\end{enumerate}



\section{Missing function declaration for defrule/deffunction/...}


Aquest error acostuma a donar-se quan ens hem descuidat de posar el parèntesis que tanca la definició d'una regla/funció/etc. i aquesta es ``solapa'' amb la següent regla/funció/etc.
Per exemple:

\begin{verbatim}
(defrule pregunta-A
 (precondicio pre)
 =>
 (assert (accio realitzada))
     ; <--- aquí falta un parèntesis que tanqui la regla

(deffunction funcio-B
 ...
)\end{verbatim}


\section{Check appropiate syntax for if/switch/loop-for-count/...}


Aquest error ens apareixerà quan no hem respectat la sintaxi d'alguna de les estructures de control de flux com if, switch, loop-for-count, etc. Pot deure's a qualsevol motiu (falta de parèntesis, expressions incorrectes), però sempre dins de la estructura de control que ens indica CLIPS.

Per exemple:

\begin{verbatim}
(switch (?resposta) ; <---- sobren els parèntesis que engloben la ?resposta!!!
   (case 1  then (assert (fet primer)) )
   ...
)
\end{verbatim}


\section{Problemas con paréntesis}

Se trata de uno de los errores más típicos a la hora de compilar y a su vez más difíciles de depurar. El problema se encuentra en que no hemos cerrado todos los paréntesis que se han abierto.
Una forma rápida para comprobar si la forma de colocar los paréntesis es la correcta, seria sumar 1 cuando se abre un paréntesis y restar 1 cuando se cierra, de manera que si al final su cómputo es 0, es correcto. Por ejemplo:


\begin{verbatim}
        (  (  2  +  3 )  *  ( 4  /  ( 1 + 1 ) ) )
      0 1  2          1     2       3         2 1 0
\end{verbatim}
Es muy recomendable y facilita mucho la tarea de encontrar bugs, ponerlos tabulados con comentario en el cierre

\begin{verbatim}
(while
...
) ;endwhile
\end{verbatim}

\chapter{Referencias}

\section{On puc trobar informació sobre el llenguatge CLIPS?}

Llegeix-te la ``CLIPS User Guide''. És un document que explica amb un llenguatge
senzill tot el que es pot fer amb CLIPS, començant amb coses fàcils i es va
complicant mica en mica. Veuràs que és una mica llarga, però és prou
entretinguda de llegir. La pots trobar a l'adreça següent:

\href{http://www.ghg.net/clips/download/documentation/usrguide.pdf}{
\texttt{http://www.ghg.net/clips/download/documentation/usrguide.pdf}}.
No obstant, a la ``CLIPS User Guide'' només hi ha els conceptes més importants.
Si no trobes alguna cosa, consulta la ``CLIPS Basic Programming Guide'', que
trobaràs aquí:

\href{http://www.ghg.net/clips/download/documentation/bpg.pdf}{\texttt{
http://www.ghg.net/clips/download/documentation/bpg.pdf}}.

\section{Otras referencias}

\begin{itemize}
\item
\href{
http://www.lsi.upc.edu/~bejar/ia/material/laboratorio/clips/clips4.pdf}{{
\tt
http://www.lsi.upc.edu/\~{}bejar/ia/material/laboratorio/clips/clips4.pdf}}
\item
\href{http://www.gsi.dit.upm.es/~cif/cursos/ssii/clipshtml/clips-index}{{
\tt
http://www.gsi.dit.upm.es/\~{}cif/cursos/ssii/clipshtml/clips-index}}
\item \href{http://www.geocities.com/aitorsjs/html/clips.pdf}{{\tt
http://www.geocities.com/aitorsjs/html/clips.pdf}}
\item \href{http://scalab.uc3m.es/~docweb/ia/practicas/clips.pdf}{{\tt
http://scalab.uc3m.es/\~{}docweb/ia/practicas/clips.pdf}}
\item \href{http://vmbenet.iespana.es/IMG/pdf/Fpract3.pdf}{{\tt
http://vmbenet.iespana.es/IMG/pdf/Fpract3.pdf}}
\item \href{http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}{{\tt
http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}}
\item
\href{http://www.lsi.upc.es/~bejar/ia/material/laboratorio/clips/bpg.pdf}
{{\tt
http://www.lsi.upc.es/\~{}bejar/ia/material/laboratorio/clips/bpg.pdf}}
\item
\href{
http://www.lsi.upc.es/~bejar/ia/material/laboratorio/clips/usrguide.pdf}{
{\tt
http://www.lsi.upc.es/\~{}bejar/ia/material/laboratorio/clips/usrguide.pdf}}
\item Manual molt bo (i extens) de CLIPS, escrit per Aitor San Juan Sánchez
(castellà)

\href{http://www.geocities.com/aitorsjs/html/clips.pdf}{{\tt
http://www.geocities.com/aitorsjs/html/clips.pdf}}

\item Basic programming guide (anglès):

\href{http://www.csie.ntu.edu.tw/~sylee/courses/clips/bpg/node1.html}{{
\tt http://www.csie.ntu.edu.tw/\~{}sylee/courses/clips/bpg/node1.html}}

\item Basic Programing guide Vol. 1 (anglès):

\href{http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}{{\tt
http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}}

\item Manual resumit de clips (castellà):

\href{http://scalab.uc3m.es/~docweb/ia/manual/manual/manual.html}{{\tt
http://scalab.uc3m.es/\~{}docweb/ia/manual/manual/manual.html}}

\item Manejo Básico de clips (castellà):

\href{http://trevinca.ei.uvigo.es/~jgarcia/SIEX/Clips.html}{{\tt
http://trevinca.ei.uvigo.es/\~{}jgarcia/SIEX/Clips.html}}

\item 6 Tutorials curts de clips (anglès):

\href{http://iweb.tntech.edu/bhuguenard/ds6530/ClipsTutorial/tableOfContents.htm}
{{\tt
http://iweb.tntech.edu/bhuguenard/ds6530/ClipsTutorial/tableOfContents.htm}}

\item Un fòrum (com el fòrum de IA de la FIB) d'un altre universitat espanyola
(castellà):

\href{https://apps.lab.inf.uc3m.es/foro/viewforum.php?f=59}{{\tt
https://apps.lab.inf.uc3m.es/foro/viewforum.php?f=59}}
\item Problemes resolts sobre CLIPS (anglès):

\href{
http://pesona.mmu.edu.my/~ytbau/tes3211/expert_systems_problems_and_sol.html}{{\tt
http://pesona.mmu.edu.my/\~{}ytbau/tes3211/expert\_systems\_problems\_and\_sol.html}}

\end{itemize}
\end{document}
\documentclass[11pt,svgnames]{scrbook}
\usepackage{a4wide}
\usepackage{epsfig}
\usepackage{amsfonts}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times} 
\pagestyle{plain}
%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper, landscape]
\usepackage{amssymb}
\usepackage{cclicenses}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}

\usepackage[a4paper,margin=1.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\rightmark}
\fancyhead[RE]{\leftmark}
\fancyhead[LE,RO]{\thepage}
\addtolength{\headheight}{2.5pt}
\fancyfoot{}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\renewcommand{\chaptermark}[1]{%
\markboth{\chaptername\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}} 
\usepackage{tikz}

\usepackage[explicit]{titlesec}
\newcommand*\chapterlabel{}
\titleformat{\chapter}
  {\gdef\chapterlabel{}
   \normalfont\sffamily\Large\bfseries\scshape}
  {\gdef\chapterlabel{\thechapter.\ }}{0pt}
  {\begin{tikzpicture}[remember picture,overlay]
    \node[yshift=-3cm] at (current page.north west)
      {\begin{tikzpicture}[remember picture, overlay]
        \draw[fill=Black!25] (0,0) rectangle
          (\paperwidth,3cm);
        \node[anchor=east,xshift=.9\paperwidth,rectangle,
              rounded corners=20pt,inner sep=11pt,
              fill=Black!75]
              {\color{white}\chapterlabel#1};
       \end{tikzpicture}
      };
   \end{tikzpicture}
  }
\titlespacing*{\chapter}{0pt}{50pt}{0pt}

\titleformat{\section}
{\normalfont\sffamily\bfseries}
{\filright\Large\thesection}{0.5em}{
\Large\bfseries#1 \titleline[c]{\titlerule[1mm]}}

\titlespacing*{\section}{0pt}{25pt}{-5pt}

\titleformat{\subsection}
{\normalfont\sffamily\bfseries}
{\filright\large\thesubsection}{0.5em}{\large\bfseries
#1 \titleline[c]{\titlerule[0.3mm]}}

\titlespacing*{\subsection}{0pt}{20pt}{5pt}


\begin{document}


\begin{titlepage}
 \colorlet{mintgreen}{green!60!black!50}

\begin{center}
  \begin{tikzpicture}[overlay]
\definecolor{palegreen}{rgb}{0.53,0.64,0.28}
\definecolor{darkred}{rgb}{0.65,0.2,0.2}
\definecolor{lightblue}{rgb}{0.22,0.57,0.76}
%\pgfdeclareimage[interpolate=true,width=10cm]{FIB}{FIB-Logo}

\draw [ultra thin,color=darkred,fill](-10,0) rectangle (10,1.5);
\draw [ultra thin,color=palegreen,fill] (-9,1.75) rectangle (-9.1,-26.5);
\draw [ultra thin,color=lightblue,fill] (-6,-16.5) rectangle (6,-17.5);
\draw [ultra thin,color=palegreen,fill] (9,-22) rectangle (9.1,-26.5);
\draw [ultra thin,color=darkred,fill] (6,-25) rectangle (9.5,-26);
\draw [ultra thin,color=darkred,fill](-10,-25) rectangle (-3,-26);

    \node [at={(-4.5,0.75  )},color=white]
        {{\fontencoding{OT1}\fontfamily{phv}\Huge Intel.ligència
 Artificial}};
     \node [at={( -6 ,-25.5  )},color=white] {\fontencoding{OT1}\fontfamily{phv}  \large CURS
2009/2010 1Q};

   \node [at={( 0,-7  )}] {\fontencoding{OT1}\fontfamily{phv} \Huge \textbf{FAQ de CLIPS}};

    \node [at={( 0,-17  )},color=white] {\fontencoding{OT1}\fontfamily{phv}\begin{large}            
                                                              \end{large}\large Departament de
Llenguatges i Sistemes
Informàtics};
    \node [at={( 7,0.25  )}] {\fontencoding{OT1}\fontfamily{phv} \large Enginyeria en Informàtica};


    \node [at={( 7.4,-25.5  )},color=white] {\large\byncsa };

%\node [at={( 0,-22.5  )}] {\pgfuseimage{FIB}};
   % \nodeshadowed [at={( 0,2  )}] {Manual for Version \pgftypesetversion};


\end{tikzpicture}



 \end{center}

\vfill

 \end{titlepage}


\newpage
\thispagestyle{empty}


\vspace*{5cm}
\begin{flushleft}
This work is licensed under the Creative Commons\\
Attribution-NonCommercial-ShareAlike License.
\byncsa\\
\ \\
To view a copy of this license, visit
{\tt  http://creativecommons.org/licenses/by-nc-sa/2.0/} or
send a letter to:
\ \\ \ \\

Creative Commons, \\
559 Nathan Abbott Way, Stanford, \\
California 94305, \\
USA.
\end{flushleft}

\thispagestyle{empty}
\newpage

\vspace*{3cm}
En la elaboración de este documento han intervenido:
\bigskip

\begin{tabular}{l}
Javier Biosca Ruíz de Ojeda\\
José Camallonga González\\
Jordi Chacón Chacón\\
Adrià Figuera Puig\\
Martí Fornés Estarellas\\
Daniel Golobart Castellote\\
Marina Grigoreva\\
Borja Jara García\\
Brian Jiménez Gracía\\
Ignacio Llatser Martí\\
Victor Lloveras Díaz\\
Isaac López Amat\\
Víctor Martínez Jurado\\
Lluís Monsalve Carrasquilla\\
Enric Munné Hernández\\
Jorge Muñoz Gama\\
Ivan Navarro González\\
Manuel Parrilla Gutierrez\\
Marcos Pereira Varela\\
Pere Sivecas Gibert\\
Lluís Suñol Juliachs\\
\end{tabular}

\bigskip
El responsable de la edición del documento es Javier Béjar alonso
(\texttt{bejar@lsi.upc.edu})

\newpage

\pagenumbering{arabic}

\tableofcontents




\chapter{Introducción}

Este documento es el resultado de la recopilación de los documentos escritos
durante el desarrollo de la práctica de sistemas basados en el conocimiento el
cuatrimestre de otoño del curso 2007-2008.

 El objetivo de estos documentos era recoger las dudas frecuentes que se encuentra un
alumno durante el desarrollo de la práctica de SBCs y consejos
prácticos que puedan ayudar en el desarrollo.

 Este documento recoge principalmente dudas frecuentes sobre el entorno CLIPS
y su lenguaje de programación.

\chapter{Protègè}

Para saber como funciona Protègè usad la ayuda de la aplicación y el material
correspondiente, estas cuestiones se refieren a como integrar lo que se
desarrolla en Protègè con CLIPS

\section{Cómo cambiar el nombre de las instancias en Protègè}

En realidad no se trata de cambiar el nombre de las instancias, sino de darle
algo más visual que un número para poder hacer las relaciones.
Si os encontráis en la pestaña de crear instancias, el último botón es una
flecha hacia abajo. Darle y luego, set display slots. Ahí debéis indicar con que
slot queréis referenciar la instancia.

\section{Com exporto una ontologia de Protégé a CLIPS?}

A Protégé, ves a File $\rightarrow$ Export to Format $\rightarrow$ CLIPS. Un cop
fet això, es crearan dos nous fitxers amb les classes i instàncies de
l'ontologia (\texttt{nom.pont} i \texttt{nom.pins}, respectivament).

Després, obre aquests dos fitxers amb un editor de text i copia el seu contingut
al fitxer CLIPS de la següent manera:
\begin{verbatim}
 copy-paste de nom.pont

(definstances instancies
 copy-paste de nom.pins
)
\end{verbatim}

\section{Per què em dóna error CLIPS al tenir una instancia que hereta de més
d'una
classe?}

Protégé permet l'herència múltiple en instàncies, però CLIPS no. En CLIPS només
poden tenir herència múltiple las classes, però no les instàncies.

La manera més senzilla de simular-ho és tenir classes que representen aquesta
herència múltiple i fer que les instàncies pengin d'elles, però és poc pràctic.

El CLIPS et permet recuperar fàcilment les instàncies que tenen un valor
específic en un slot, pel que el més senzill és tenir una única jerarquia i
incloure altres possibles classificacions com a slots.


\chapter{CLIPS}
\section{Instalación del CLIPS}

\subsection{¿Cómo instalar CLIPS?}

La herramienta CLIPS es multiplataforma y esta disponible para los tres
S.O más utilizados: Microsoft Windows, Linux y Mac OS X.

\subsubsection*{¿Cómo instalar CLIPS en Windows?}

Primero de todo debemos bajarnos el programa de la página oficial de CLIPS,
accesible desde este
link\break
\href{http://clipsrules.sourceforge.net/}{\texttt{
(http://clipsrules.sourceforge.net/)} }. Desde el área de descarga os podreis bajar el instalador
para windows.


\subsubsection*{¿Cómo instalar CLIPS en Linux?}

En muchas distribuciones de Linux 
CLIPS esta disponible como un paquete adicional, el paquete suele instalar la
versión con interfaz gráfico. Si no encuentras el paquete específico para la distribucion que usas
siempre puedes compilarlo a partir del paquete con los fuentes.




\subsubsection*{¿Cómo instalar CLIPS en Mac OS X?}

Primero de todo debemos bajarnos el programa de la página oficial de CLIPS,
accesible desde este link\break
\href{http://clipsrules.sourceforge.net/}{(\texttt{http://clipsrules.sourceforge.net/} } ). Desde
el área de descarga podeis bajar el intalador para MAC OS X.

\subsection{Entorn finestres VS Consola de comandes}


Encara que l'entorn de finestres és molt més intuïtiu, CLIPS a la seva versió en
línea de comandes és molt més ràpid (segurament perquè no ha de mostrar en tot
moment l'agenda de fets, les instancies, les regles, etc..).

La diferencia de velocitat és molt notable, en cas de problemes de rendiment o
de sensació que l'entorn de finestres es queda penjat (o directament es tanca
sense previ avís) recomanem provar la versió en línea de comandes.


\section{Los hechos}

\subsection{¿Qué es un hecho en CLIPS?}

Conceptualmente, un hecho representa un dato abstracto del cual almacenamos valores. Se  puede ver como una lista de campos, donde el primer campo hace referencia al ``dato'' al cual le asignamos una lista de valores que le suceden, teniendo una relación entre sí.

Formalmente, el primer campo es un símbolo y los campos restantes son valores.
\medskip

\texttt{(símbolo  valor1 valor2  ...  valorN)}

\subsection{¿Qué es un hecho ordenado (order Facts)?}

Un hecho ordenado tienen formato libre, por lo tanto no existe restricción alguna en el orden de los campos. Los campos de un hecho ordenado pueden ser de cualquier tipo primitivo de datos, excepto el primero, que debe ser un símbolo.
Como ejemplo tenemos:


\begin{verbatim}
(hermanos Antonio Javier Carlos)
(padre Pedro David)
(num-hijos Pedro 2)\end{verbatim}

\subsection{¿Qué es un hecho no ordenado (deftemplates facts)?}



A través de los hechos no ordenados podemos abstraernos de la estructura de un hecho, asignado  un nombre a cada campo (slots).

\begin{verbatim}
  (deftemplate   nombre-template   "comentario"
       (slot nombre-slot  (tipo-del-slot))
       (multislot nombre-slot  (tipo-del-slot))
  )
\end{verbatim}

Por ejemplo:

\begin{verbatim}
(deftemplate avión
        (slot nombre_avion (type STRING))
        (slot compania (type STRING))
        (slot numero_plazas (type INTEGER) (default 100))
)\end{verbatim}

\subsection{¿Puedo tener un vector como slot?}

Si, debe declararse como multislot.

\subsection{¿Puedo asignar propiedades a los slots?}

Sí, las más importantes son:
\begin{description}
 \item[Type:]
 El tipo de dato primitivo que contiene (en mayúsculas).
\item [Allowed-X:] Permite especificar un conjunto de valores permitidos. Siendo \texttt{X} un tipo
de datos primitivo (en minúsculas y plural) $\rightarrow$ si el slot toma un valor del tipo
\texttt{X} debe pertenecer a los valores permitidos. \texttt{X} puede ser \texttt{values}
especificando entonces todos los valores posibles que puede tomar el slot independientemente del
tipo de dato.
\item [Range:] Especifica un rango para slots numéricos.
\item [Cardinality:] Números mínimo y máximo de elementos que puede tener un multislot.
\item [Default:] Valor por defecto. Si ponemos \texttt{?NONE} como valor por defecto significará que
no se podrá crear la instancia a no ser que se especifique el valor de ese slot.
 \end{description}

\begin{verbatim}
(deftemplate estudiante
 (slot edad (type INTEGER) (range 0 99))
 (multislot asignaturas (type STRING) (cardinality 1 5))
 (slot num-carreres (default 1))
 (multislot notas (allowed-strings "MH" "NP"))
)
\end{verbatim}

\subsection{¿Qué debo utilizar, hechos ordenados o no ordenados?}

Como se puede intuir si tenemos un conjunto de hechos los cuales conceptualmente pertenecen al mismo ámbito, será una solución más elegante agruparlos a través de un deftemplate. En caso que tengamos que algún hecho aislado, será mas sencillo declararlo como un hecho ordenado.




\subsection{Fets o Objectes?}


Veient la definició de deftemplate podem confondre'ns a l'hora de decidir si fer servir fets o fer servir objectes.

Deixant de banda altres diferències ja comentades (les classes suporten
jerarquia de classes, herència, etc..), els objectes es fan servir per
representar el coneixement (mitjançant un conjunt d'instàncies).

Així que, generalment, farem servir classes i objectes per representar coneixement, mentre que farem servir els fets per portar control sobre l'execució del problema.

Per exemple, podríem definir un deftemplate per emmagatzemar un resultat o per poder controlar l'estat de l'execució.

A la pràctica de Mikeo (penjada a la web de l'assignatura) teníem un deftemplate \texttt{habitacion-actual}

\begin{verbatim}
(deftemplate habitacion-actual
 (slot habitacion)
 (slot area-restante)
 (slot presupuesto-restante)
 (slot precio-total)
 (slot prioridad-actual)
)
\end{verbatim}

Amb el qual controlàvem la construcció d'una habitació. Assignàvem una instància de la classe
habitació al slot \texttt{habitacion} de \texttt{habitacion-actual} i mitjançant una sèrie de regles
que feien unificació amb \texttt{habitacion-actual} actuàvem sobre l'habitació d'una manera o d'un
altre.

\subsection{Creación de hechos (assert/deffacts)}

Si queremos crear un solo hecho utilizaremos el comando \texttt{assert}. Por ejemplo:
\texttt{(assert (casa roja))}

Si por el contrario queremos crear una estructura ordenada de hechos utilizaremos deffacts:
\medskip

\texttt{(deffacts mishechos (casa roja) (pelota azul))}




\subsection{Modificar un fet}


Per modificar un fet (per exemple, molt útil si estem treballant amb deftemplates) ho podem fer mitjançant \texttt{(modify <INSTANCIA> <FETS>)}.

Per exemple, si tinguéssim el deftemplate persona

\begin{verbatim}
(deftemplate persona
 (slot nom)
 (slot edad)
 (slot dni)
) \end{verbatim}

I haguéssim afegit el fet:

\begin{verbatim}
(assert (persona (nom "Pepe")(edad 25)(dni "46974431")))\end{verbatim}

I el fet:

\begin{verbatim}
(assert (aniversari "46974431"))
\end{verbatim}

Podríem tenir la següent regla:

\begin{verbatim}
(defrule aniv
  ?aniversari <- (aniversari ?dni)
  ?persona <- (persona (edat ?edat)(dni ?dni))
  =>
  (retract ?aniversari)
  (modify ?persona (edat (+ 1 ?edat)))
)
\end{verbatim}

La qual s'activarà si hi ha un fet aniversari d'una persona. Fent servir el dni indicat al fet
aniversari, busquem el fet persona que té el mateix dni. Deixem el valor edat a la variable
\texttt{?edat} per poder treballar amb ella més endavant.

Hem agafat també la direcció del fet aniversari per tal de poder esborrar-lo de la base de fets. Això s'ha fet per dues raons:

Primer, per mantenir més neta la base de fets.
Segon, i més important: Com que hem canviat el fet, la regla tornarà a fer unificació amb el fet
(perquè ara és diferent) amb la regla aniversari, amb el que entraria dintre d'un bucle sense fi on
s'aniria incrementant l'edat de la persona.

Un cop hem esborrat el fet aniversari, incrementem en 1 el valor del slot \texttt{edat} de  la
persona, fent servir la variable \texttt{?edat} que hem declarat a la part esquerre de la regla.

\subsection{Com elimino un fet de la base de fets?}


Per eliminar un fet de la base de fets ho podem fer amb la paraula clau
\texttt{(retract
<FET>)}, on \texttt{<FET>} és un punter al fet.

Per obtenir aquest fet, ho podem fer fent servir \texttt{<VAR> <- <FET>} a la
part esquerre de la regla.

Per exemple:

\begin{verbatim}
(defrule accionsvent
 ?vent <- (vent ?tipus)
 =>
 (switch ?tipus
    (case poc then (assert (accio persiana0)))
    (case normal then (assert (accio persiana50)))
    (case molt then (assert (accio persiana100)))
 )
 (retract ?vent)
)
\end{verbatim}

Afegirà fets per realitzar les accions pertinents i esborrarà el fet de la base
de fets.


\section{Variables}
\subsection{Variables a clips}


No cal declarar una variable (ni el seu tipus), només cal afegir un interrogant
al començament d'un simbol per indicar que és una variable.

CLIPS s'encarrega del control de tipus depenent del que assignem a la variable.

Per exemple, \texttt{?testvar} correspondria a la variable \texttt{testvar}. Si
per exemple, assignéssim l'enter \texttt{3} a \texttt{?testvar} CLIPS tractaria
la variable com una variable entera.

\subsection{Com assignar un valor a una variable?}


Per assignar un valor a una variable es fa servir el mètode \texttt{(bind)}, amb
la forma:
\medskip

\texttt{(bind <VARIABLE> <VALOR>)}
\medskip

On \texttt{<VALOR>} pot ser un valor o un mètode que retorni un valor.
Per exemple, si volem assignar un 4 a la variable \texttt{?var}:
\medskip

\texttt{(bind ?var 4)}
\medskip

O per exemple, podríem assignar a la variable \texttt{?var} la suma de 2 més 2:
\medskip

\texttt{(bind ?var (+ 2 2)) }

\subsection{¿Cómo declarar variables globales?}

Para crear una variable global hay que meterla dentro de la construcción defglobal. La declaración de la variable seguirá el modelo:   \texttt{ ?*nombreVariable* = expresión}

Por ejemplo:
\medskip

\texttt{(defglobal ?*presupuesto* = 0)}
\medskip

Pueden aparecer en la parte izquierda de las reglas si no son utilizadas para asignar un valor y su cambio no activa reglas, pero no pueden ser parámetros de funciones ni métodos.

\subsection{¿Cómo trabajar con variables, sumando, restando, ... por ejemplo
contadores?}

La mejor forma es con variables globales, se definen así
\texttt{(defglobal ?*x* = 0)}, puede ser el valor que queramos, tanto número,
string, ...
Y si queremos sumarle 10 por ejemplo:
\medskip

\texttt{(bind ?*x* (+ ?*x* 10))}
\medskip

Las variables locales, como por ejemplo \texttt{?x}, sólo tienen valor mientras
dura su ejecución y eso suele ser en esa misma línea o en un bucle. Si le damos
valor a \texttt{?x} y luego preguntamos por ella, nos dirá que no existe.

\subsection{Quina diferència hi ha entre les variables del tipus
{\tt ?nom\_variable} i les del tipus {\tt \$?nom\_variable}?}

Les primeres contenen un sol valor, i les segones en poder contenir més d'un (o
cap).


\subsection{Què significa l'interrogant (?) quan va sol?}

És una variable anònima. Pots utilitzar \texttt{?} sense posar-hi cap nom si
no t'interessa el valor en concret.
Per exemple:
\medskip

\texttt{(Primer filtre\_preu ?)}
\medskip

Aquesta condició significa ``si el fet \texttt{(Primer filtre\_preu)} té algun
valor''. O sigui, que si tinguéssim el fet \texttt{(Primer filtre\_preu ok)} es
compliria la condició (i si en comptes de ``ok'' fos ``patata'' també es
compliria). En canvi, si el fet fos únicament \texttt{(Primer filtre\_preu)} no
es compliria la condició.

\subsection{Què significa el dòlar (\$) quan va sol?}

És com l'interrogant, però admet més d'un valor. Per exemple:
\medskip

{\tt (Primer filtre\_preu \$ ok)}
\medskip

donarà cert pels fets de l'estil \texttt{(Primer filtre\_preu patata ok)},
\texttt{(Primer filtre\_preu hola ok)}, \texttt{ (Primer filtre\_preu patata
hola ok)},
\texttt{(Primer filtre\_preu ok)}.
És a dir, no importa els valors que hi hagi entre \texttt{filtre\_preu} i ok, si
al final hi ha un ok.

\subsection{¿Como puedo ver los hechos presentes en un momento determinado?}

Abriendo la Facts Window en Window de la barra de menú.


\section{Las reglas}

\subsection{¿Cómo construir una regla?}

Para construir una regla utilizaremos la construcción defrule:

Sintaxis:

\begin{verbatim}
(defrule <nombre-regla> [<comentario>]
  [<declaración>]
  <elemento-condición>* ; Parte izquierda (LHS)
   =>
  <acción>*) ; Parte dcha. (RHS) de la regla
\end{verbatim}

Una regla consta de un conjunto de condiciones (antecedente), también
denominados elementos condicionales (EC) o parte izquierda (LHS), y de un
conjunto de acciones (consecuente), también denominado parte derecha de la regla
(RHS). La regla se activará siempre que se satisfagan todos los EC mediante
hechos o instancias que los cumplan.

Si se introduce en la base de reglas una nueva regla con el mismo nombre que el de una
existente, la nueva regla reemplazará a la antigua.

Si una regla no tiene parte izquierda, es decir, no tiene elementos condicionales, entonces
el hecho \texttt{(initial-fact)} actuará como el elemento condicional para ese tipo de
reglas, y la regla se activará cada vez que se ejecute un comando reset.


\subsection{¿Cómo gestionar la parte izquierda (LHS) de una regla?}

\subsubsection*{Declarar hechos}


Si no se especifica ninguna condición la regla se activará siempre. 
Una condición puede ser un simple hecho (Ej. \texttt{vegetariano}) o un hecho
ordenado con unos valores concretos (Ej. \texttt{(persona (nombre Juan))}).
Si lo que queremos es obtener el valor de un hecho insertaremos una variable en
su lugar (Ej. \texttt{(persona (nombre ?n))} ). Entonces entrará en la regla
para cada valor posible que pueda asignar a la variable \texttt{?n} a partir de
los
hechos.

Si queremos indicar cualquier valor utilizaremos el símbolo \texttt{?} y para
cualquier
lista el símbolo \texttt{\$?} (Ej. \texttt{(evento ?) (estilo \$?)} ).
También existe la opción de guardar en una variable una referencia al objeto.
Ello se consigue poniendo \texttt{var <-} a su izquierda (Ej. \texttt{?p <-
(persona
(nombre Juan))}). Se puede usar por ejemplo para pasárselo de parámetro a una
función llamada en la RHS.


\subsubsection*{Establecer condiciones}

Además podemos especificar restricciones adicionales sobre los valores que puede
tomar un campo de un hecho. Existen tres tipos principales de restricciones: 
Conectadas (por orden de precedencia o prioridad) 
\begin{description}
 \item not (\verb|~|):
  Evita que cierto campo cumpla determinada restricción. 
\item and (\verb|&|): Combina dos restricciones conjuntivamente. 
\item or (\verb+|+): Combina dos restricciones disjuntivamente. 
\item De predicado (\verb|:|) : Obliga a que cierto campo cumpla determinada
condición (especificada por el predicado). 
\item Por valor devuelto por una función \verb|=|: Permite llamar a una función
y utilizar el valor devuelto para restringir el valor que pueda tomar un campo
de un hecho. 

Se puede comprobar si se cumple una determinada condición mediante el
constructor
\texttt{test}. Dentro de \texttt{test} se pueden hacer llamadas a cualquier
función o predicado, ya
sea primitiva de CLIPS o definida por nosotros.
\end{description}

\subsubsection*{Combinar elementos}


Los diferentes elementos de la parte izquierda van
implícitamente unidos mediante una \texttt{AND}, que indica conjunción. No
obstante podemos hacerlo explícitamente mediante \texttt{(and (cond1) (cond2))},
aunque suelen utilizarse para anidar \texttt{ANDs} dentro de \texttt{ORs}.

\texttt{OR} Sirve para hacer una disyunción \texttt{(or (cond1) (cond2))}. Es
equivalente a escribir varias reglas en las que cada una de ellas tenga uno de
los componentes del OR en su parte izquierda, y la misma parte derecha.

\texttt{NOT} Sirve para detectar si no existe un determinado hecho (Ej. 
\texttt{(not (estilo sibarita)))}. 

\texttt{exists} Cuando a un conjunto de elementos se le antecede exists, se
comprueba que hay al menos un hecho en la base de hechos que cumpla la condición
(Ej. \texttt{(exists(bebida ?precio: (< ?precio 5)))} )

\texttt{forall} Permite comprobar si todos los hechos que satisfacen un
determinado patrón, cumplen una serie de condiciones (Ej. \texttt{(forall(plato
(estilo moderno))})




\subsection{¿Cómo obtener la dirección de hechos o instancias situados en LHS?}

En algunas ocasiones, vamos a necesitar realizar algún tipo de acción en la parte derecha de las reglas sobre hechos o instancias que cumplan unas determinadas condiciones. Pero para ello necesitaremos primero tener acceso a estos elementos para después poder operar sobre ellos. Esto lo conseguiremos guardando la dirección del elemento en una variable haciéndolo del siguiente modo:
\medskip

\texttt{?variable\_direccion <- (elemento)}
\medskip


Pongamos un ejemplo para ver realmente el funcionamiento y uso de esta posibilidad que CLIPS nos ofrece:

\begin{verbatim}
(defrule imprime-area
  ?instancia <- (object (is-a Rectangulo))
  =>
  (printout t "Area del rectangulo " (instance-name ?instancia) 
                             ":" (send ?instancia calcula-area) crlf)
)
\end{verbatim}

Cuando se ejecuta esta regla, se imprimirán las áreas de todas las instancias de
la clase \texttt{Rectangulo}. En la parte izquierda de la regla, lo que hacemos es
guardar en la variable instancia la dirección de la instancia de \texttt{Rectangulo} que
estamos tratando en ese momento. La regla se ejecutará para todas las instancias
almacenadas en la memoria de trabajo que cumplan la condición (\texttt{is-a
Rectangulo}), es decir, para todas las instancias de la clase
\texttt{Rectangulo}. En la parte derecha de la regla, donde se ejecutan las
acciones, podemos ver que se imprimirá, para cada instancia, lo siguiente:
\texttt{Area del rectangulo \texttt{[nombre\_instancia]}: área del rectángulo}.
La función \texttt{instance-name} nos devuelve el nombre de la instancia que le
pasamos por parámetro. Además, hemos llamado al gestor de mensajes \texttt{calcula-area}
para que nos devuelva el area del rectángulo.

\subsection{¿Cómo hacer sentencias or en la izquierda de las reglas?}

Con \texttt{(or ...)}. Si por ejemplo tenemos dos hechos \texttt{(a)} y \texttt{(b)} y queremos
ejecutar la derecha de la regla cuando se cumpla uno de los dos, tendremos que hacer \texttt{(or (a)
(b))}. Atención porque la parte derecha se ejecutará tantas veces como veces se cumpla cada uno de
los hechos, si para nosotros existe tanto \texttt{(a)} como \texttt{(b)}, la parte derecha se
ejecutará dos veces. Para que sólo se usa una vez, podemos hacer combinaciones de or y and (funciona
igual) o usar un patrón, por ejemplo \texttt{(persona Juan|Pedro)} sólo se ejecutaría una vez.


\subsection{Com afegir una condició a la part esquerre d'una regla?}


A vegades és necessari que una regla s'instanciï si es produeix una condició especial (i no un fet).
Per fer aixó, farem servir la comanda \texttt{(test <CONDICIO>)}.

Per exemple, imaginem que la nostre base de fets compte amb un fet \texttt{(preu
?valor)} amb un preu determinat. Imaginem que volem una regla que s'instanciï
quan aquest valor és més gran que 30.

Per fer-ho, fent servir tot el que hem explicat,

\begin{verbatim}
(defrule preucar
 (preu ?preu)
 (test (> ?preu 30))
 =>
 (printout t "El preu es mes gran que 30")
)
\end{verbatim}

És a dir, si el preu és més gran que 30 s'imprimirà un missatge per pantalla.

Aquestes condicions poden contenir ANDs i ORs de varies condicions.

Per exemple,

\begin{verbatim}
(defrule preulimit
  (preu ?preu)
  ?factminim <- (preuminim ?minim)
  ?factmax <- (preumaxim ?maxim)
  (test (and (> ?preu ?minim) (< ?preu ?maxim) ))
   =>
  (retract ?factminim)
  (retract ?factmax)
  (printout t "El preu està dintre del rang")
) \end{verbatim}

On comprovarem si el preu està dintre d'un rang determinat i en aquest cas, esborra els fets que contenen el màxim preu i el mínim preu i mostra un missatge per pantalla.


\subsection{Puede una misma regla ejecutarse más de una vez?}

Es muy importante entender que cada regla se ejecutará una vez por cada
combinación de valores en su LHS.


\begin{verbatim}
(defrule regla 
   (color ?col)
   (peso ?pes)
 =>
...
\end{verbatim} 

Si tengo tres colores y dos pesos asertados la regla se ejecutará 6 veces, una
con cada combinación de color y peso. 




\subsection{Com puc definir l'ordre de les regles?}

La idea d'un sistema basant en regles és no definir un ordre lineal d'aquestes
(costa deixar de pensar de forma iterativa)

En el cas de necessitar que una regla s'executi després d'una altre, pots fer
servir Fets: la regla anterior crea un fet, que la segona regla tindrà a la part
esquerra:

\begin{verbatim}
(defrule pregunta1
 =>
 (assert (pregunta1Feta))
 ....
)

(defrule pregunta2
 (pregunta1Feta)
 =>
 ....
)
\end{verbatim} 

I finalment, pots usar la propietat \texttt{salience}. Aquesta propietat indica
la prioritat d'execució de les regles ( les regles amb salience majors
s'executaran abans ). Pot prendre valors positius i negatius entre -10.000 y
+10.000. Per defecte les
regles tenen salience 0:

\begin{verbatim}
(defrule pregunta1
 (declare (salience 2))
 =>
 ....
)

(defrule pregunta2
 (declare (salience 1))
 =>
 ....
)
\end{verbatim} 

El valor indicado en la propiedad \texttt{salience} puede ser el número
directamente o una expresión, por ejemplo \texttt{variable*10},
podemos usar \texttt{variable} para elegir que regla se ejecutará. 

Las prioridades deben ser usadas solo para determinar el orden en el que se
disparan algunas reglas sobre otras, no para fijar el flujo de control ya que la
principal ventaja de un sistema basado en reglas es la representación
declarativa del conocimiento y de esta forma, abusando de las prioridades,
conduce a un sistema procedimental.




\subsection{Com forçar que una regla sigui la primera?}

Per que aquesta regla sigui la primera ha de tenir el salience més gran de
totes.

\begin{verbatim}
(defrule presentacio
 (declare (salience 20))
 =>
 (printout t "------ Benvingut -----" crlf)
)
\end{verbatim} 

\subsection{Vull guardar certs valors que es fan servir durant l'execució de diferents regles. Com ho puc fer?}

Tens principalment dues alternatives. Si el valor és un tipus bàsic, pots fer servir una variable global, amb la sintaxi següent:
\medskip

\texttt{(defglobal ?*nom\_variable* = valor)}
\medskip


Aquesta sentència no va a dins de cap funció ni regla, es posa sola a la part que creguis convenient del codi.
Vegem un exemple:
\medskip

\texttt{(defglobal ?*preu\_minim\_primer* = 1000)}
\medskip


Per fer-la servir es fa exactament de la mateixa manera que amb una variable normal, però has de posar els dos asteriscs. Per exemple:
\medskip

\texttt{(bind ?*preu\_minim\_primer* ?curr-preu)}
\medskip

Per altra banda, si el valor o valors que vols guardar han de ser instàncies, una bona estratègia pot ser utilitzar un deftemplate. És útil sobretot per anar guardant solucions temporals, o llistes d'elements que poden formar part de la solució.

Per utilitzar-ho has de seguir els passos següents.

\begin{enumerate}
 \item  Definir el deftemplate:


\begin{verbatim}
(deftemplate nom_del_deftemplate
  (multislot nom_multislot)
   ...
  (slot nom_slot)
)
\end{verbatim}

Amb un exemple es veurà més clar:

\begin{verbatim}
(deftemplate llista-plats
 (multislot primers)
 (multislot segons)
 (multislot postres)
)
\end{verbatim}

\item Inicialitzar el deftemplate

\begin{verbatim}
(defrule
  [condicions vàries]
  ; La condició base és que llista-plats no s'ha inicialitzat encara.
  (not (llista-plats))
=>
  ; ?llista conté els valors de llista-plats (que de moment estan buits)
  (bind ?llista (assert (llista-plats)))
\end{verbatim}

\item  Assignar-li valors

\begin{verbatim}
(bind ?segons_plats (find-all-instances ((?plat Plat)) TRUE)
(modify ?llista (segons ?segons_plats))
\end{verbatim}

\item Recuperar els valors

\begin{verbatim}
(defrule
  [condicions vàries]
  ?llista <- (llista-plats (segons $?segons_plats))
=>
  ...
\end{verbatim}

Ara, la variable \texttt{\$?segons\_plats} conté tots els elements de segons.


\end{enumerate}



\section{Las clases/instancias}

\subsection{Tengo que representar la jerarquía de un frame ¿Es preferible añadir
las
subclases a la ontología o bien diferenciarlas mediante un slot en la
superclase?}


Las dos formas son válidas, pero es recomendable representarlas en clases separadas cuando se vayan a buscar instancias de ese tipo, ya que así no tendremos que hacer un recorrido por todas las de la superclase. No obstante, si sólo se trata de una característica puntual del frame y no vamos a hacer búsquedas de una exclusiva subclase entonces será más eficiente añadir un slot debido a su mejor accesibilidad.



\subsection{¿Qué es un objeto?}

Podríamos decir que un objeto, es un hecho no ordenado  con herencia.

\subsection{¿Porqué usar objetos en contexto de la práctica de
CLIPS de IA?}

Como bien sabemos, una parte de la práctica de SBC's consisten en crear la
ontología. Esta ontología se exporta para poder interactuar con CLIPS en formato
\texttt{.pins} y \texttt{.pont}. El archivo \texttt{.pont} contendrá la
declaración de todas las clases creadas previamente por Protege
\texttt{(defclass )}. El archivo \texttt{.pins} contendrá todas las instancias
de las clases declaradas en el archivo \texttt{.pont}. Como puede intuir el
lector, se necesitará interactuar con los objetos previamente creados por
Protègè.

\subsection{Como se definen las clases?}

Para definir las clases usaremos el constructor defclass:

\begin{verbatim}
(defclass  <nombre>  [<comentario>]
 (is-a  <nombre-de-superclase>)
 [(role concrete | abstract)]
 [(pattern-match reactive | non-reactive)]
 <slot>* ;;; definición de los atributos de la clase
<documentación-handler>*
)\end{verbatim} 

En caso de desear que la nueva clase herede las propiedades de otra ya
existente, el nombre de esta deberá especificarse despues de \texttt{is-a}. El
rol determinará si la clase es concreta (se puede instanciar) o abstracta
(destinada a ser superclase). El \texttt{pattern-match} debe declararse como
reactivo si
se desea que las instancias de la clase puedan unificar con los elementos
objeto
de las reglas (símbolo \texttt{<-}). Los \texttt{slots} corresponden a los
atributos de la
clase y los \texttt{handlers} a las funciones de ésta. Los handlers se pueden
declarar en
la declaración de la propia clase, pero se deben definir externamente. Dado que
no aporta ninguna ventaja declararlos es recomendable definirlos directamente.
Nótese que todo aquello que está entre corchetes (\texttt{[]}) constituye
información adicional que no es obligatorio especificar.

\begin{verbatim}
(defclass Persona
 (is-a Ser_Vivo)
 (role concrete)
 (single-slot edad
  (type INTEGER)
  (range 1 99)
  (cardinality 0 1)
  (create-accessor read-write)
 )
 (multislot amigos
  (type INSTANCE)
  (allowed-classes Persona)
 )
)
\end{verbatim} 

El comportamiento y declaración de los slots es idéntico al de los slots de los
hechos ordenados. Los atributos de tipo \texttt{INSTANCE} (referencian otras
instancias)
estan en formato \texttt{INSTANCE-NAME} .

\subsection{Com consulto una instància a partir d'una regla?}


Podem fer servir la part esquerre d'una regla per trobar instàncies. L'ús és
molt semblant a trobar el punter a un fet, fent servir
\medskip

\texttt{(object (is-a <NOM\_CLASSE>))}
\medskip

Per exemple, si volem que una regla s'instanciï si tenim instanciat un plat de
la classe Plat, podriem fer servir:

\begin{verbatim}
(defrule tenimplat
 ?plat <- (object (is-a Plat))
=>
(print t (send ?plat get-nom) crlf)
)\end{verbatim} 

La regla imprimirà el nom del plat que trobi. És important notar que s'activarà
per cada instància de plat que tinguem a la base de coneixement.

Podem consultar els valors de la instancia fent servir condicions a la part
esquerre de la regla. Per exemple, si només volguéssim els plats amb un preu més
gran que 30:

\begin{verbatim}
(defrule platcar
 ?plat <- (object (is-a Plat))
 (test (> (send ?plat get-preu) 30))
 =>
 (print t (send ?plat get-nom) " es car." crlf)
) \end{verbatim} 

S'activarà per tots els plats amb un preu major a 30.

S'ha d'anar amb cura per aquest tipus de regla, ja que si la base de coneixement
és molt amplia pot acabar derivant amb problemes de memòria.

Per exemple, si en comptes de preguntar per una instància de Plat, preguntéssim
per dues instancies de Plat:

\begin{verbatim}
(defrule platcar
 ?plat1 <- (object (is-a Plat))
 ?plat2 <- (object (is-a Plat))
 (test (> (send ?plat1 get-preu) 30))
 (test (> (send ?plat2 get-preu) 30))
 =>
 (print t (send ?plat1 get-nom) " i " (send ?plat1 get-nom)   " són cars."
crlf)
)
\end{verbatim} 

Faria unificació amb totes les combinacions possibles (amb repeticions) de dos
plats de tota la base de coneixement. Això es podria anar ampliant fins fer-se
intractable.


\subsection{¿Cómo realizar una búsqueda de instancias que cumplan unas
restricciones?}

CLIPS nos ofrece varias funciones de búsqueda de instancias que cumplan unas
determinadas restricciones que a nosotros nos interese:

\begin{itemize}
\item 
La función \texttt{find-instance}: Esta función devuelve la primera instancia
que cumple
todas las restricciones indicadas. 
\item La función \texttt{find-all-instances}: Esta función devuelve todas las
instancias que
cumplen las restricciones indicadas.
\end{itemize}

La sintaxis de ambas funciones es igual exceptuando el nombre de la función:

\texttt{(find-all-instances (clase\_instancias) (restricciones))}. 

A continuación se muestran varios ejemplos:

\begin{itemize}
\item 
\texttt{(bind ?rectangulos (find-all-instances ((?inst Rectangulo)) (>
?inst:altura
10)))}.  Después de ejecutar esta función, en la variable rectangulos habrá una
lista con todas las instancias de la clase Rectangulo cuya altura sea superior a
10. 

\item \texttt{(bind ?rectangulos (find-all-instances ((?inst Rectangulo)) (and
(>
?inst:altura
10) (= ?inst:anchura 7))))}. Este trozo de código hace que en la variable
rectangulos se guarde una lista de las instancias de la clase Rectangulo que
tienen una altura superior a 10 y una anchura igual a 7.\end{itemize}



Estas funciones que CLIPS nos ofrece tienen otra funcionalidad y es que podemos
realizar búsquedas de conjuntos de instancias:


\begin{itemize}
\item 
\texttt{(bind ?rectangulos (find-all-instances ((?a Rectangulo) (?b Rectangulo))
(=
?a:altura ?b:altura)))}. Con este trozo de código conseguiríamos obtener todas
las parejas de instancias de la clase Rectangulo que tienen la misma altura. 
\end{itemize}

Por último, es necesario comentar que se pueden realizar búsquedas de conjuntos
de instancias que sean de distintas clases:


\begin{itemize}
\item 
\texttt{(bind ?figuras (find-all-instances ((?rect Rectangulo) (?circ Circulo))
(=
?rect:altura ?circ:radio)))}. Con este trozo de código conseguiríamos obtener
todas las parejas \texttt{<rectangulo,circulo>} que cumplan que la altura del
rectángulo
sea igual al radio del círculo.\end{itemize}


Existen más comandos para obtener instancias, pero son menos utilizadas a nivel
básico, como pueden ser, \break \texttt{any-instancep}, \texttt{do-for-instance},
\texttt{do-for-all-instances} y \texttt{delayed-do-for-all-instances}.




\subsection{¿Cómo se interactúa con objetos?}

La interacción con objetos se efectúa mediante lo que se denomina mensaje. 

\begin{verbatim}
(defmessage-handler
  <nombre-clase>
  <nombre-mensaje>
  [<tipo-handler>] [<comentario>]
  <parámetro>* [<parámetro-comodín>])
  <acción>*
)\end{verbatim} 

Un gestor de mensajes consta de 7 partes:
\begin{enumerate}
\item  Nombre de clase  a la que el gestor estará asociado
\item Nombre del mensaje
\item Tipo de gestor (Nosotros habitualmente usaremos primary que viene por
defecto)
\item Comentario (opcional);
\item Lista de parámetros
\item Parámetro comodín (para gestionar múltiples parámetros)
\item Secuencia de acciones o expresiones que serán ejecutadas por el gestor
\end{enumerate}

Enfocado a la práctica de CLIPS, la más común es que queramos interactuar con
objetos para:

\begin{enumerate}
 \item  Imprimir los objetos
 Un ejemplo:

\begin{verbatim}
   (defmessage-handler avion imprimir-beneficio ()
     (printout t (send ?self imprimir-beneficio) crlf)\end{verbatim} 

\item Para implementar funciones calculadas asociadas al objeto
 Un ejemplo:

\begin{verbatim}
 (defmessage-handler avion calcular-beneficio ()
  (* ?self:plazas-ocupadas ?self:precio-billete)) 
 )
\end{verbatim} 
\end{enumerate}

Como se puede observar el parámetro implícito \texttt{?self}, contiene la
instancia activa para este mensaje.

\subsection{¿Como se interactúa con las instancias de los objetos?}

Podremos interactuar entre las instancias de los objetos mediante la función
\texttt{send}.
\medskip

\texttt{(send <expresión-de-objeto> <nombre-de-mensaje>   <expresión>*)}
\medskip

Donde se toman como argumentos el objeto destino del mensaje, el mensaje mismo,
y otros parámetros que debieran ser pasados a los gestores.

Particularmente, en el ámbito de la práctica, usualmente necesitaremos
utilizar el
envió de mensajes de tipo \texttt{get}, \texttt{put} and \texttt{delete}.
Estos mensajes tiene la siguiente sintaxis:

\begin{itemize}
\item \texttt{get-<nombre-atributo>}
\item \texttt{put-<nombre-atributo>}
\item \texttt{delete}
\end{itemize}


Aquí tenemos un ejemplo de como utilizarlo, recordando que ponemos entre
corchetes la instancia la cual se envía el mensaje  

\begin{verbatim}
(defclass avion (is-a USER)
     (role concrete)
     (slot precio-billete (create-accessor read) (default 34))
     (slot plazas-ocupadas (create-accessor write) (default 0)))
;Clase creada

>(make-instance a of avion)         ;Creación de una instancia de avion
[a]
>(send [a] get-precio-billete)      ;Obtención de un slot
34                                  ;Resultado obtenido
>(send [a] put-plazas-ocupadas 100) ; Modificación de un slot
>(send [a] delete)                  ; Eliminación de la instancia
True
\end{verbatim} 


\subsection{Uso de make-instance}

Cuando queremos crear una instancia de una clase para ir rellenandola con los
resultados o datos que vayamos obteniendo se haria lo siguiente:
\medskip

\texttt{(bind ?variable\_instancia (make-instance nombre\_instancia of
nombre\_clase))}
\medskip

Una vez creada, podemos jugar con dicha instancia en las diferentes reglas,
siempre que la llamemos en los activadores:

\begin{verbatim}
(defrule regla
 ?var_instancia <- (object (is-a nombre_clase))
 => 
 ...
)\end{verbatim} 

De esta manera dentro de la regla podemos hacer acciones con la instancia, por
ejemplo:
\medskip

\texttt{(send ?var\_instancia put-articulo ?articulo\_ejemplo)}

\subsection{Com fer un get/set d'un slot d'una classe?}


Per consultar el valor d'un slot d'una classe, ho podem fer enviant-li un
missatge de la següent manera:
\medskip

\texttt{(send <VARIABLE> get-<NOM\_ATRIBUT>)}
\medskip

Per exemple, si tenim una instància de la classe Plat ( \texttt{?instancia} ) i
volem saber el valor del seu slot nom:
\medskip

\texttt{(send ?instancia get-nom)}
\medskip

Per assignar un valor a un slot d'una d'instància, hem d'enviar-li un missatge
de la següent manera:
\medskip

\texttt{(send <VARIABLE> put-<NOM\_ATRIBUT> <VALOR>)}
\medskip

On \texttt{<VALOR>} pot ser un valor o un mètode que retorni un valor.
\medskip

\texttt{(send ?instancia put-nom "nom")}


\subsection{¿Cómo acceder a una instancia cuyo nombre conocemos?}

Si conocemos el nombre de una instancia y necesitamos acceder a ella, es decir,
necesitamos enviarle algún mensaje mediante la función send, podemos hacerlo
directamente escribiendo, en lugar de la variable que almacena la instancia, el
nombre de la instancia entre corchetes \texttt{[ ]}. A continuación se muestra
un ejemplo:
\medskip

\texttt{(bind ?altura\_rect1 (send [rect1] get-altura))}
\medskip

 En este caso, se
guardará en la variable \texttt{altura\_rect1} el valor de la altura de la
instancia que tiene como nombre \texttt{rect1}.


\subsection{Obtenir el nom d'una classe}


Si tenim una instància d'una classe i volem saber el nom de la classe (útil si
tenim una bona taxonomia de classes) ho podem fer amb el mètode \texttt{(class
<INSTANCIA>)}.

Si per exemple, imaginem que tenim la classe Actor, la qual té com subclasses la
classe APrincipal, ASecundari  i ACameo. Imaginem que estem tractant amb
instancies d'actors, i volem saber si la instancia que estem tractant es de la
classe APrincipal.

Ho hauríem de fer de la següent manera:
\medskip

\texttt{(eq (class ?instancia) APrincipal)}
\medskip

Fixem-nos que \texttt{APrincipal} és un símbol, no un String (un truco és
fixar-se en que
no té cometes). Si volguéssim comparar-ho amb un String (per exemple, un String
introduït per l'usuari) ho podríem transformar a un String amb el mètode
\texttt{str-cat}.
\medskip

\texttt{(eq (str-cat  (class ?instancia)) "Principal")}


\subsection{Como convierto un INSTANCE-ADRESS en un INSTANCE-NAME?}

En algún momento nos podemos encontrar con la situación de que disponemos de un
puntero a una instancia y necesitamos su nombre o lo contrario. En ambos casos
podemos usar la función instance-name. Su funcionamiento es bidireccional,
podemos introducirle un instance-name y nos devolverá un instance-adress y
viceversa.

\begin{verbatim}
(defrule imprimir-nombre
 ?est<-(object (is-a Estudiante) (edad 25))
 =>
 (printout t (instance-name ?est) crlf)
)
\end{verbatim} 

\subsection{Com iterar a través d'un multi-slot?}


El següent també és vàlid com exemple de com iterar a través d'una llista.

Imaginem que tenim una instància de la classe Plat a la varible
(\texttt{?plat}), la qual té un
multi-slot d'instàncies de la classe Ingredient. Imaginem que volem imprimir per
pantalla el nom d'aquests ingredients (slot nom de la classe Ingredient):
Necessitarem iterar sobre la llista d'ingredients.

\begin{verbatim}
(bind ?i 1)
 (while (<= ?i (length$ (send ?plat get-ingredients)))
  do
  (bind ?ingredient (nth$ ?i (send ?plat get-ingredients)))
  (printout t (send ?ingredient get-nom) crlf)
 (bind ?i (+ ?i 1))
)
\end{verbatim} 

El mètode \texttt{(nth\$ <INDEX> <LLISTA>)} et retorna l'element situat a
\texttt{INDEX} de \texttt{LLISTA}. 

El mètode \texttt{(length\$ <LLISTA>)} retorna el número d'elements de LLISTA.


\subsection{Cómo recorrer un atributo multievaluado}

Supongamos que la variable respuesta tiene una lista de instancias

\begin{verbatim}
(loop-for-count (?i 1 (length$ ?respuesta)) do  
 (bind ?aux (nth$ ?i ?respuesta)) 
 ;aquí hacemos lo que queramos 
 ) 
) \end{verbatim} 
 
\texttt{Loop-for-count} funciona como un for, primero la variable que hará
de contador, luego el valor de origen y luego el valor final. Para controlar el
final usamos la función que he explicado antes.
\texttt{i} tomará valores desde 1 hasta n, así que usando la función
\texttt{nth\$} obtendremos cada uno de los elementos. La variable \texttt{?aux} irá
teniendo cada uno de los valores.

\subsection{Cómo recorrer un atributo multievaluado de un atributo multievaluado
(una
matriz).}

Es igual que antes pero con dos bucles


\begin{verbatim}
(loop-for-count (?i 1 (length$ ?respuesta)) do 
 (bind ?aux (nth$ ?i ?respuesta)) 
 (bind ?aux2 (send ?aux get-slot_que_queremos)) 
 (loop-for-count (?j 1 (length$ ?aux2)) do 
  (bind ?aux_final (nth$ ?j ?aux2)) 
  ;aquí ya podemos trabajar con el elemento en concreto
 ) 
) 
\end{verbatim} 

Supongamos que respuesta tiene una lista de instancias, con el primer bucle
haremos lo mismo que antes, ir iterando por esas instancias. Una vez que tenemos
cada instancia con \texttt{aux2}, con el segundo bucle iteraremos dentro de sus
instancias interiores.

Por ejemplo, si tenemos varios equipos de fútbol y cada equipo tiene varios
jugadores, en el primer bucle estamos iterando entre los equipos y en el segundo
entre los jugadores de cada equipo en particular.


\subsection{Com puc esborrar una instància?}


Per esborrar una instància (per exemple, segons la informació que proporcioni
l'usuari podem deduir que una sèrie d'instàncies és impossible que es facin
servir per a la solució) ho podem fer enviant un missatge delete a la instància,
és a dir \texttt{(send <INSTANCIA> delete)}. 
\medskip

\texttt{(send ?inst delete)}
\medskip

Un mètode que podria ser útil de la cara a la pràctica podria ser el següent:

\begin{verbatim}
(defrule elimina-instancia
 (declare (salience 10))
 ?elimina-fact <- (elimina-inst ?inst)
 =>
 (send ?inst delete)
 (retract ?elimina-fact)
)\end{verbatim} 

Imaginem que per exemple que volem eliminar una llista d'instàncies. Per
eliminar-les, podríem recórrer el llistat marcant les instàncies que volem
esborrar afegint el següent fet:
\medskip

\texttt{(assert (elimina-instancia ?inst))}
\medskip

Així, com que elimina-instancia té un salience alt esborraria les instàncies
marcades quan tingués ocasió.

D'aquesta manera ens estalviem el problema de recórrer un llistat d'instàncies
amb un iterador mentre anem eliminant els elements de la llista, cosa que pot
donar problemes amb l'iterador.


\subsection{Com imprimir una instància?}


Per imprimir una classe (útil per exemple per mostrar el resultat final) el
millor és definir message-handlers.

Per exemple, imaginem que tenim una classe \texttt{Plat}, la qual té un slot
\texttt{nom} de tipus String. Si volguéssim imprimir per pantalla un
missatge que digués:
\medskip

\texttt{El nom del plat és --<nom del plat>--}
\medskip

Hauríem de definir un message-handler que simplement imprimís per pantalla el
valor de l'slot, de la forma:

\begin{verbatim}
(defmesssage-handler <CLASSNAME> <MESSAGENAME> primary ()
   <CODI>
)
\end{verbatim} 

Per el cas de l'exemple: 

\begin{verbatim}
(defmessage-handler Plat print primary ()
 (printout t "--" ?self:nom "--") )
)
\end{verbatim} 

Per cridar-ho, només caldrà enviar-li un missatge a la instància amb el nom del
message-handler (en aquest cas, \texttt{print}).
\medskip

\texttt{(send ?instancia print)}
\medskip

Un message-handler pot cridar a altres message-handlers, amb el que es poden
encadenar diverses instàncies. Per exemple, imaginem que tenim la classe Menú,
la qual té un atribut plats que és un llista d'instàncies de la classe Plat.
Dintre del message-handler menú, podríem iterar a través de la llista de plats
enviant el missatge print que hem definit anteriorment.

	
\subsection{Com es navega entre instàncies relacionades?}
 Per exemple, tinc una instància iA
que té un slot anomenat slotB que és una instància d'un frame B. Vull saber el
nom de la instància associada al slotB de iA.
Ho pots fer així:

\begin{verbatim}
(bind ?B (send ?iA get-slotB))
(bind ?res (send ?B get-nom))
\end{verbatim} 

Si estàs dins d'una condició, ho pots simplificar de la forma següent:
\medskip

\texttt{(bind ?res (send ?iA:slotB get-nom)}
\medskip

Els dos punts són equivalents al punt de
Java



\section{Programación}
\subsection{Com introduir un comentari?}


Els comentaris a CLIPS va darrere de un\texttt{;}, com per exemple:
\medskip

\texttt{;Comentari}
\medskip

També podem afegir comentaris a les nostres regles, deffacts, deftemplates,
etc. Generalment van darrere el nom de la estructura, per exemple:

\begin{verbatim}
(defrule neteja "regla per la qual si la cuina està bruta s'afegirà una tasca de
neteja"
 (estat-cuina bruta)
  =>
 (assert (tasca netejar))
)
\end{verbatim}

\subsection{Referenciar el valor null a CLIPS?}


Per referenciar el valor null a clips es fa amb el simbol \texttt{nil}. Per
exemple, si volem saber si una instància \texttt{?inst} es null, ho podríem fer
de la següent manera:
\medskip

\texttt{(eq ?inst nil)}


\subsection{Formas de recorrer una lista:}

Para recorrer una lista disponemos de diferentes opciones, en este FAQ
explicaremos como crear una estructura tipo ``WHILE'' y tipo ``FOR''.

\begin{enumerate}
 \item \texttt{While}: Esta regla se ejecuta hasta que la expresión a evaluar sea falsa. Este tipo de
 estructura se rige por seguir la sintaxis \texttt{while} - \texttt{do}, y se construiría de la
siguiente forma:


\texttt{(while  <expresión>  [do]  <acción>)}

	Dónde dependiendo del valor de  \texttt{<expresión>}:

\begin{itemize}
 \item Valor  TRUE: Se realizará la acción \texttt{<acción>} i se volverá a evaluar \texttt{<expresión>}.
\item Valor  FALSE:  No se ejecutará la acción \texttt{<acción>}

\end{itemize}



\item \texttt{For}: Esta regla sirve para ejecutar un bucle N (final - inicio) veces. Este tipo de
estructura se rige por seguir la sintaxis \texttt{loop-for-count}, , y se construiría de la
siguiente forma:

\texttt{(loop-for-count   (<var>  <inicio>   <final>)  [do]   <acción>)}


Dónde:

\begin{itemize}
 \item \texttt{<var>}:  Variable que se usara como índice.
\item \texttt{<inicio>}:  Valor inicial que tendrá \texttt{<var>}
\item \texttt{<final>}:  Ultimo valor que tendrá la variable \texttt{<var>}
\item \texttt{<acción>}: Acción que es realizará hasta que \texttt{<var>} tenga el valor de \texttt{<fin>}
\end{itemize}


\end{enumerate}


\subsection{Formas de elegir una opción}

En este apartado explicaremos como crear una estructura \texttt{if} y una estructura
 \texttt{switch}.
\begin{itemize}
 \item \texttt{If}: Este tipo de estructura se rige por seguir la sintaxis
i\texttt{f -
then - else}, y se construiría de la siguiente forma:

\texttt{(if    <expresión>     then     <acción>     [else    <acción2>])}

	Dónde dependiendo del valor de  <expresión>:

\begin{itemize}
\item Valor  TRUE: Se realizará la acción \texttt{<acción>}.
\item Valor FALSE: Se realizará la acción \texttt{<acción2>} (en caso de haber)
\end{itemize}

\item \texttt{Switch}: Este tipo de estructura se rige por seguir la sintaxis
\texttt{switch - opciones}, y se construiría de la siguiente forma:

\begin{verbatim}
(switch   <expresión-test>
 (case OPCION1   then   ACCION1)
 (case OPCION2   then   ACCION2)
            .
            .
            .
 ([default]   ACCION-DEFAULT)
)
\end{verbatim}

Dónde dependiendo del valor de \texttt{<expresión-case>} se ejecutará una  \texttt{<acción>} en particular. Si ninguna \texttt{<opción>} es correcta, se ejecutara la \texttt{<acción-default>}.
\end{itemize}



\subsection{Funciones con la clase String}

	Habitualmente trabajaremos con Strings o cadena de Strings. CLIPS
proporciona una serie de herramientas para trabajar con esta clase:
\begin{enumerate}
 \item Convertir string a MAYÚSCULAS: A veces es conveniente tener todos los
caracteres en mayúsculas para no tener problemas de comparaciones o simplemente
por convenio. Para ello, CLIPS dispone de la función \texttt{upcase}, la cual
convierte a mayúsculas un símbolo o string.

\texttt{(upcase  <expresión-simbólica-o-de-cadena>  )}

Ejemplos:

\texttt{(upcase ``Clips es divertido'')}  $\rightarrow$ \texttt{``CLIPS ES
DIVERTIDO''}

\texttt{(upcase  Clips\_es\_divertido) } $\rightarrow$ 
\texttt{CLIPS\_ES\_DIVERTIDO}

\item Convertir string a MINÚSCULAS: la función es \texttt{downcase}.

\item Concatenación de strings: También es de gran utilidad poder juntar dos o
más parámetros  en un solo string.  Todo parámetro a juntar deben ser de uno de
los siguientes tipos: symbol. String, integer, float o instance-name.

\texttt{(str-cat      parametro1     parametro2     ...     parametroN  )}

Ejemplo:

\texttt{(str-cat "IA"{} nota 10)}  $\rightarrow$  \texttt{"IAnota10"}

\item Comparación de strings:  Función que nos indica si dos strings son
iguales.

\begin{verbatim}
(str-compare
      <expresión-simbólica-o-de-cadena> 
      <expresión-simbólica-o-de-cadena>
)\end{verbatim} 

Esta función devuelve:
\begin{description}
 \item 0:   Si ambos strings son iguales.
\item 1:   Si el primer string es mayor que el segundo string. 
\item -1: Si  el primer string es menor que el segundo string.

 \end{description}

\item Longitud de un string: Muchas veces es de gran utilidad saber que tamaño
tiene un string.:

\texttt{(str-length    <expresión-simbólica-o-de-cadena>)}

Ejemplo:

\texttt{(str-length "Inteligencia Artificial")}  $\rightarrow$ \texttt{23}

\end{enumerate}

\subsection{¿Cómo obtener el contenido de una variable en un string?}

Para conseguir un string a partir de un integer, float, symbol, instance-name, ... debes utilizar el comando \texttt{str-cat}. Si a la función le pasamos como parámetros varios elementos, los transformará a string y los concatenará. La sintaxis de esta función es la siguiente: \texttt{(str-cat elemento/s)}.
Esta función la usaremos sobre todo cuando queramos realizar comparaciones entre el contenido de una variable y un string ya que previamente, necesitaremos usar la función \texttt{str-cat} para pasar el contenido de la variable a string y realizar de este modo la comparación de forma correcta.


\subsection{¿Como se crea una lista?}

Con \texttt{create\$}. Todos los operadores sobre listas llevan el símbolo \$ al
final. Igual que con las variables se debe usar bind siempre que se desee
modificar una lista.
\medskip

\texttt{(bind ?lista (create\$ a b c))}

\subsection{¿Como borro un elemento de una lista?}

Con \texttt{delete\$}.Usa la siguiente sintaxis: 

\texttt{(delete\$ <lista>\ 
<indice-inicio>\  <indice-final>)}. 

Se borrarán todos los elementos del rango
entre las posiciones inicio y final, ambas incluidas. También existe\break
\texttt{delete-member\$}: \texttt{(delete-member\$ <lista> \  <elemento>)}.
Borrará todas las apariciones del elemento en la lista.
\medskip

\texttt{(delete\$ (create\$ a b c d e f) 3 5)} $\longrightarrow$
 \texttt{(a b f)}

\subsection{¿Como inserto elementos en una lista?}

Con\texttt{ insert\$}. Sintaxis: 

\texttt{(insert\$ <lista> <indice> <expresión
simple o
lista>)}.

Inserta todos los valores simples o de multicampo en la lista antes del
índice-ésimo valor (\texttt{<índice>} debe ser un entero) de la lista dada.
\medskip

\texttt{(insert\$ (create\$ a b c d) 1 x)} $\longrightarrow$ 
 \texttt{(x a b c d)}

\subsection{¿Como modifico elementos de una lista?}


Con \texttt{replace\$}. Sintaxis: 

\texttt{(replace\$ <lista-a-modifcar>\
<inicio>\ <final>\ <lista-nuevos-valores>)}. 

Los valores entre las posiciones
inicio y final serán
substituidos por la nueva lista. 
Recordar que el uso de bind es imprescindible  si queremos conservar los
cambios.
\medskip

\texttt{(replace\$ (create\$ a b c) 3 3 x)}$\longrightarrow$
 \texttt{(a b x)}

 \subsection{¿Como averiguo el número de elementos de una lista?}


Con \texttt{length\$}. Sintaxis \texttt{(length\$ <lista>)}.

\subsection{¿Como consulto un valor de la lista a través de su posición?}

A través de \texttt{nth\$}. Sintaxis: \texttt{(nth\$ <índice> <lista>)}.

\subsection{Como recorro todos los elementos de una lista?}


Manualmente con un bucle y \texttt{nth\$}, o con \texttt{progn\$}.
Sintaxis:\texttt{(progn\$ (<var> <lista>))}. La variable iterará sobre todos los
valores de la lista ordenadamente.

\begin{verbatim}
(progn$ (?var (create$ abc def ghi))
(printout t "-->" ?var "<--" crlf))
--> abc <--
--> def <--
--> ghi <--
\end{verbatim} 


\subsection{Com trobar si un element forma part d'una llista?}


Per comprovar que un element formi part de la llista (seguint l'exemple
anterior, com saber si un ingredient forma part de la llista d'ingredients)
podem fer servir \texttt{(member <ELEMENT> <LLISTA>)}, el qual retorna un booleà
indicant si l'element pertany a la llista o no.


\subsection{Tinc un conjunt de símbols, però estan tots junts en un string. ¿Com
ho faig per
separar-los i posar-los en un multislot?}

Has d'utilitzar la funció explode\$ de CLIPS, amb la sintaxi següent:
\medskip

\texttt{(explode\$ string)}
\medskip

Per exemple, si tenim una data en un string i volem extreure el dia:
\medskip

\texttt{(bind ?dia (nth\$ 1 (explode\$ ?data)))}

\subsection{I si tinc un multislot i el vull transformar en un string?}

Has d'utilitzar la funció implode\$ de CLIPS, amb la sintaxi següent:
\medskip

\texttt{(implode\$ multislot)}
\medskip

Per exemple, si volem crear un string que conté una data:
\medskip

\texttt{(bind ?data (implode\$ (create\$ 12 1 2008)))}


\subsection{¿Cómo obtener un valor aleatorio?}

Es probable que en algunos casos necesitemos obtener un valor aleatorio para realizar algún tipo de acción. CLIPS nos ofrece esta posibilidad mediante la función random, que retorna un número entero aleatorio:
\medskip

\texttt{(bind ?rand (random)).}

\subsection{Comparaciones}

Para comparar dos elementos: \texttt{(operador elemento1 elemento2)}. Siendo
operador \texttt{eq}, \texttt{<}, \texttt{=}, \texttt{>}, ...
Por ejemplo:
\medskip

\texttt{(eq ?nuevo TRUE)}

\texttt{(< ?precio ?saldo)}
\medskip

Un caso específico es la igualdad ya que varía en función del tipo de los
elementos comparados. Si se trata de un número se utilizará el operador
\texttt{=}, en caso de que los elementos sean objetos o símbolos \texttt{eq}.
Finalmente si estamos tratando cadenas debemos utilizar la función
\texttt{str-compare}. Esta devuelve un número entero que representa el resultado
de la comparación: 0 (son idénticos), 1 (elemento1 $>$ elemento2) o -1
(elemento1 $<$ elemento2).

De esta forma, si por ejemplo queremos comparar si dos cadenas son iguales, la
condición sería:
\medskip

\texttt{(= (str-compare "verano" "verano") 0)}



\section{Los módulos}

\subsection{Què és un mòdul en CLIPS?}


Els mòduls en clips són el mecanisme que ens proporciona aquest per tal de dividir, organitzar i, en alguns casos, fer més eficient, la execució de les nostres bases de coneixement. Ens poden ser útils, per exemple, per dividir un problema en diversos subproblemes, com per exemple, per dividir un problema en un primer subproblema d'anàlisis i un segon de construcció de la solució.

Els mòduls es defineixen de la següent manera:
\medskip

\texttt{(defmodule <nom-mòdul>)}
\medskip

Un mòdul només pot ser definit un cop, i no podrà ser tornat a definir mai, a excepció del mòdul
\texttt{MAIN}, que es pot redefinir tan sols un cop. Cal tenir en compte que cada mòdul té la seva
pròpia agenda.

\subsection{Partición en modulos}

Para que el sistema experto sea mucho más sencillo de actualizar y de
comprender, es muy aconsejable hacer una partición en módulos. Lo que hacemos
con esto es agrupar las reglas que busquen un objetivo en común. La construcción
de un módulo se hace poniendo \texttt{(defmodule nombre\_del\_modulo "La
descripción del módulo"  (import ...) (export ...))}. Un módulo termina en
donde empieza otro módulo, así que no hay que cerrar declaración, sino que se
hace implicitamente. En los apartados de import deberemos de poner todos
aquellos módulos de los cuales queramos obtener y usar sus reglas. Los export
son para indicar a los demás módulos que se puede usar de si mismo. Definir los
módulos si luego no se puede navegar por ellos no sirve para nada. Para eso está
el comando focus, el cual, seguido de un nombre de módulo, sirve para
especificar que el sistema va a estar centrado, focalizado, en el módulo
especificado. El uso de focus es muy adecuado como consecuente de una regla, por
ejemplo:

\begin{verbatim}
(defrule cambio-modulo-estilo-menu
  (Evento nombre_reserva ok)
  (Evento numero_comensales ok)
  (Evento temporada ?)
  (Evento presupuesto ok)
 =>
  (focus preguntas-estilo-menu)
)
\end{verbatim}

Cuando una regla no está en ningún módulo, es decir, el usuario no la ha incluido en ningun módulo, decimos que está en el módulo MAIN.


\subsection{¿Cómo asignar una construcción en un módulo?}

Existen dos formas para incluir una construcción en un módulo:
\begin{description}
 \item[Explícita:]
 se escribe el nombre del módulo (que es un símbolo) seguido de dos puntos(\texttt{::}), que
 representan el símbolo separador de módulos, y a continuación el nombre. Ej.
 (\texttt{MÓDULO::construcción})

\item [Implícita:] sin especificar el nombre del módulo ni los dos puntos \texttt{::}, ya que siempre existe un módulo ``actual''. El módulo actual cambia siempre que:
\begin{itemize}
 \item se defina una construcción defmodule
\item se especifica el nombre de un módulo en una construcción (usando \texttt{::})
\item se utilice la función s\texttt{et-current-module <nombre-módulo>}.
\end{itemize}
\end{description}

\subsection{Com funcionen les clàusules \texttt{export} i \texttt{import}?}


Abans de res, cal advertir que només es poden exportar i importar: \texttt{deftemplate}, \texttt{defclass}, \texttt{defglobal}, \texttt{deffunction} i \texttt{defgeneric}.

Hi ha 3 maneres d'exportar o importar construccions:
\begin{enumerate}
 \item Exportant/important el conjunt global de totes les construccions d'un mòdul

\begin{verbatim}
(defmodule modulA (export ?ALL) )
(defmodule modulB (import modulA ?ALL) )
\end{verbatim}
\item Exportant/important totes les construccions d'un mòdul que són d'un tipus particular

\begin{verbatim}
(defmodule modulA (export deftemplate ?ALL) )
(defmodule modulB (import modulA deftemplate ?ALL) )
\end{verbatim}
\item Exportant/important construccions específiques

\begin{verbatim}
(defmodule modulA (export deffunction funcio-util-1 funcio-util-2) )
(defmodule modulB (import modulA deffunction funcio-util-1 funcio-util-2) )
\end{verbatim}
\end{enumerate}


Per poder importar construccions d'un altre mòdul, és un requisit que aquest mòdul estigui definit abans del mòdul on estem definint la importació i que el mòdul estigui exportant les consrtuccions que voldrem usar en el nou mòdul.

Exemple:

\begin{verbatim}
(defmodule modulA (export deffunction funcioAdeu)) 
; exportem només la funció funcioAdeu

(deffunction modulA::funcioAdeu ()
 (printout t "Bye from ModuleA!" crlf)
)

(defmodule MAIN (import modulA ?ALL)) 
;importem totes les construccions de modulA

(defrule MAIN::inicio
     (initial-fact)
     =>
     (printout t "Hello from MAIN module!" crlf)
     (funcioAdeu)
)
\end{verbatim}
Si executem aquest codi obtindrem la següent sortida:

\begin{verbatim}
CLIPS> (run)
Hello from MAIN module!
Bye from ModuleA!
CLIPS>
\end{verbatim}




\subsection{¿Cómo cambio el módulo actual?}

El módulo \texttt{MAIN} es definido automáticamente por CLIPS y es el módulo actual por defecto
cuando se inicia por primera vez o después de un comando clear. Cada módulo tiene su propia agenda
(conjunto conflicto). Entonces la ejecución puede controlarse seleccionando una agenda, y en ésta se
elegirán reglas para ejecutar. Se puede cambiar el módulo actual mediante el comando focus:
\medskip

Sintaxis: \texttt{(focus <nombre-módulo>+)}
\medskip

CLIPS mantiene una pila de focos, y cada vez que se hace un cambio de módulo se añade el foco actual en el top de la pila. La ejecución de las reglas continúa hasta que cambia el foco a otro módulo, no haya reglas en la agenda, ó se ejecute return en la RHS de una regla.

En las reglas existe la propiedad auto-focus, que permite ejecutar automáticamente un comando focus cuando la regla se activa:
\medskip

Sintaxis: \texttt{(auto-focus TRUE | FALSE)}

\subsection{¿Como debería utilizar las focos en la practica de CLIPS?}

La manera más natural de organizar los módulos en la práctica de clips es de
manera lineal y con un  orden de ejecución consecutiva. Esto quiere decir, que
si nuestra práctica tiene 5 módulos estarán escritos de manera lineal m1, m2,
m3, m4 y m5 y querremos que se ejecuten de manera consecutiva : Primero m1,
después m2 así consecutivamente hasta llegar a m5.
De esto se deduce que al final de cada módulo, colocaremos un foco que nos
redirija al siguiente módulo. 

La redirección o salto al siguiente módulo puede ser de dos tipos :
\begin{enumerate}
 \item Incondicional: 

Queremos que independiente de que reglas se hayan cumplido el foco nos
redireccione al siguiente modulo. En este caso será suficiente con la sentencia

\texttt{(focus modulo-siguiente)}

\item Condicional:
Lo más habitual es queramos saltar al siguiente módulo solo si se han cumplido
una serie de reglas. La solución en este caso es incorporar el foco en la parte
derecha de la regla:

\begin{verbatim}
(defrule saltar-siguiente-modulo
 (declare (salience 0))
 (r1 ?)
 (r2 ?)
 (r3 ?)
 (r4 ?)
 (r5 ?)
 ->
 (focus modulo-siguiente)
)
\end{verbatim} \end{enumerate}

Como podrá apreciar el lector se ha incluido una  sentencia condicional en la
parte izquierda es: \texttt{(declare (salience 0))}. Mediante esta instrucción
podemos asignar una prioridad en el orden de ejecución a la regla. 
  En este caso se
ha asignado prioridad 0, suponiendo que todas las reglas restantes del módulo
tienen una prioridad más alta (por ejemplo 10), asegurándonos que será la última
en ejecutarse.


\section{Funciones}



\subsection{¿Cómo se crea una función en CLIPS?}

Una deffunction se compone de cinco elementos:
\begin{enumerate}
 \item Un nombre, que debe ser un símbolo.
\item Un comentario, que es opcional.
\item Una lista de cero o más parámetros requeridos, que deben ser variables
simples)
\item Un parámetro comodín opcional que sirve para manejar un número variable
de
argumentos.
\item Una secuencia de acciones o expresiones que serán ejecutadas en orden
cuando
se llame a la función.
\end{enumerate}



\begin{verbatim}
(deffunction
     <nombre>                  (1)
     [<comentario>]            (2)
     (<parámetro>*             (3)
     [<parámetro-comodín>])    (4)
     <acción>*                 (5)
)
\end{verbatim}

El valor devuelto por la función es la última acción o expresión evaluada dentro
de la función.  Si una deffunction no tiene acciones, devolverá el símbolo
\texttt{FALSE}. Si se produce algún error mientras se ejecuta la función,
cualquier otra acción de la función aún no ejecutada se abortará, y la función
devolverá el símbolo \texttt{FALSE}.

Ejemplo:

\begin{verbatim}
(deffunction
   mostrar-params                                Nombre (1)
   (?a ?b                                        Parámetro  simples (3)
   $?c)                                          Parámetro múltiple  (4)
   (printout t ?a " " ?b " and " (length ?c)
                         " extras: " ?c crlf)    Acción (5)
)\end{verbatim}

La función anterior guarda los dos primeros parámetros dentro de las variables
\texttt{?a} y \texttt{?b} y el resto (en caso de haber) en \texttt{\$?c}. Esta función realiza la
acción de imprimir por pantalla un mensaje formado por:

    Los valores de las variables \texttt{a} y \texttt{b}  +  and + longitud de la variable
\texttt{c} + extras + valores de \texttt{c}

Si  ejecutamos la función definida anteriormente con dos parámetros:
\texttt{(mostrar-params 1 2)} el valor de cada variable será:
\begin{description}
 \item[?a]= 1
\item[?b]= 2
\item [?c]= Vacio
 \end{description}



E imprimirá: \texttt{1 2 and 0 extras: ()}

Si  ejecutamos la función definida anteriormente con cuatro parámetros:
(mostrar-par a b c d) el valor de cada variable será:

\begin{description}
 \item[?a]= a
\item[?b]= b
\item [?c]= c d
 \end{description}

E imprimirá: \texttt{1 2 and 2 extras: (c d)}

\subsection{Explicación de la estructura de una función en general.}

Hacer una función en CLIPS es igual que en cualquier otro lenguaje. Se ha de
tener en cuenta que la función no tiene activadores como en una regla.
Únicamente, ésta tiene que ser colocada dentro del módulo donde va a ser
utilizada y siempre tiene que devolver algo (tal como se verá en el ejemplo de
estructura siguiente).
Ejemplo:

Si en pseudocódigo tuviésemos:

\begin{verbatim}
funcion devuelvo_boolean (lista L1, lista L2)
{
 boolean b = false;
 int i = 1;
 mientras(i<=N && !b)
 {
  ...
  i++;
  }
 return b;
}
\end{verbatim}

En CLIPS quedaria así:
\begin{verbatim}
(deffunction devuelvo_boolean (?L1 ?L2)
  (bind ?b FALSE)
  (bind ?i 1)
  (while (and (<= ?i  N) (not ?b))
    do
    ...
    (bind ?i (+ ?i 1))
  )
 ?b
)
\end{verbatim}

\subsection{Com definir un paràmetre d'una funció com una llista?}


Si volem que un paràmetre de la funció sigui una llista, ho haurem d'indicar amb un \texttt{\$}. Per
exemple,

\begin{verbatim}
(deffunction pertany (?var $?llista) (member ?var ?llista))
\end{verbatim}

Retornaria si var forma part d'una llista.

La manera d'indicar que un paràmetre és una llista seria la mateixa per els fets
a la part esquerre d'una regla.


\subsection{Com puc utilitzar una funció a la part esquerra de les regles?}

Fent servir la instrucció \texttt{test}.
test es satisfà si la funció retorna qualsevol valor diferent de FALSE
\medskip

\texttt{(test (estaALaLlista ?persona1 \$?personesConvidades ))}


\section{Entrada salida}

\subsection{¿Cómo se imprime por pantalla?}

	Para imprimir por pantalla sin especificar el formato de cada parámetro
se usa la función \texttt{printout}.

\texttt{(   printout  nombre-logico  <parámetro>+  )}


\begin{itemize}
 \item \textbf{Nombre-lógico:} Envía al dispositivo asociado con el nombre
lógico especificado
un string formateado. Puede tener uno de los siguientes valores:
\begin{itemize}
 \item \textbf{Nil:} No se produce salida pero devuelve el string formateado.
\item \textbf{T:} Se imprime en la salida estándar.
\end{itemize}
\item\textbf{ Parámetros:} Los parámetros pueden ser:
\begin{itemize}
 \item \textbf{Variables:}  Si queremos imprimir el valor de una variable
debemos escribir un
interrogante y su nombre:  \texttt{?nombreVariable}
\item \textbf{Resultado de funciones:}  Si queremos escribir el valor de retorno
de una función
deberemos escribir entre paréntesis la función a ejecutar:
\texttt{(nombreFuncion)}
\item \textbf{Strings:} Si queremos escribir una cadena des Strings, deberemos
poner la cadena
de strings entre comillas: \texttt{"loQueQuieraEscribir"}.
\end{itemize}




\end{itemize}




Si por el contrario queremos especificar el tipo de cada parámetro a imprimir,
usaremos la función \texttt{format}.

\texttt{(   format    <nombre-logico>     <string-control>     <parámetros>*
)}

\begin{itemize}
 \item \textbf{Nombre-lógico:} Envía al dispositivo asociado con el nombre
lógico especificado
un string formateado. Puede tener uno de los siguientes valores:
\begin{itemize}
 \item \textbf{Nil:} No se produce salida pero devuelve el string formateado.
\item \textbf{T:} Se imprime en la salida estándar.
\end{itemize}


\item \textbf{String-Control:} El string de control contiene unos flags de
formato que indican
cómo serán impresos los parámetros.  Estos flags son de la forma :
\texttt{\%[-][M][.N]x},
donde:
\begin{itemize}
 \item -: Es opcional y significa justificado a la izquierda (por defecto
derecha).
\item M: Indica la anchura del campo en columnas. Como mínimo se imprimirán M
caracteres.
\item N: Específica el numero de dígitos a la derecha del punto decimal y es
opcional.
Por defecto se toman 6 para los números reales.
\item X: Especifica el formato de impresión y puede ser:
\begin{itemize}
 \item d: Entero
\item f:  Decimal
\item e: Exponencial (potencias de 10).
\item g: General (numérico). Imprimir con el formato mas corto.
\item o: Octal. Numero sin signo. (N no se aplica)
\item x: Hexadecimal.
\item S: String.
\item N: Salto de línea.
\item R: Retorno de carro.
\item \%: el carácter ``\%''.
\end{itemize}

\end{itemize}


\item \texttt{Parámetros:} Parámetros a imprimir.

\end{itemize}

\subsection{¿Al imprimir por pantalla como hago un salto de línea?}

Con \texttt{crlf}.

\subsection{Com imprimeixo una línia en blanc?}

Sense escriure cap text:
\medskip

\texttt{(printout t crlf)}




\subsection{Com llegir de la entrada standard?}


Per llegir de l'entrada estàndard CLIPS ofereix el mètode \texttt{(read)}.
Generalment, per llegir el que vol entrar un usuari farem:
\medskip

\texttt{(bind ?text (read))}
\medskip

Això deixarà a la variable \texttt{?text} el que escrigui l'usuari fins que faci
un retorn de carro.

Si volem comprovar que la resposta sigui un String podem fer
servir, \texttt{(lexemep
<VALOR>)} el qual comprova que \texttt{VALOR} sigui  un String o un Symbol.

Si el que volem és un enter, podem fer servir \texttt{(integerp <VALOR>)}, que
comprova que VALOR sigui un enter.


\subsection{Vull llegir un número (o conjunt de números) com un string, però
CLIPS me'ls
llegeix com un enter}

Utilitza la funció \texttt{(readline)} en lloc de la funció \texttt{(read)}.
\medskip

{\bf nota adicional:} Las funciones \texttt{(read)} y \texttt{(readline)} tienen un comportamiento
diferente. La función \texttt{(read)} espera un elemento válido de CLIPS en la entrada (un entero,
un real, un string, un símbolo, una instancia, incluso una lista) e ignora todo lo que queda en la
entrada una vez ha reconocido el elemento válido. Este comportamiento es habitual en muchos
lenguajes de programación no imperativos (funcionales y declarativos) como por ejemplo LISP o Prolog
donde los procedimientos de lectura no se limitan a reconocer caracteres, sino que son conscientes
de las estructuras del lenguaje. La función \texttt{(readline)} es la función de tratamiento de
lectura de caracteres habitual en los lenguajes imperativos.

\subsection{Haig de fer una pregunta a l'usuari, i la resposta és un conjunt d'elements (no sé d'entrada quants), com ho faig per assignar-los a un multislot?}

Per fer això primer necessites definir una funció que llegeixi un string d'entrada (que contindrà el conjunt d'elements) i després trencar la cadena per poder distingir cada element individualment (``pasta marisc fruita'' $->$ ``pasta'' ``marisc'' ``fruita''). A l'exemple següent es veu com fer-ho:

\begin{verbatim}
; Fa una pregunta sobre una llista d'elements
(deffunction pregunta-llista (?pregunta) 
  (format t "¿%s?" ?pregunta)
  ; Llegim una línea sencera (Ex. ``Pasta Marisc Fruita'')
  (bind ?resposta (readline)) 
  ; Separem l'string (Ex. ``Pasta'' ``Marisc'' ``Fruita'')
  (bind ?res (str-explode ?resposta)) 
  ; Retornem els diferents camps (Ex. ``Pasta'' ``Marisc'' ``Fruita'')
  ?res
) \end{verbatim}


Un cop tenim la funció, l'únic que hem de fer és assignar els valors que hem llegit i processat a la variable que ens interessi. Per exemple, suposem que volem assignar la resposta a una variable anomenada ingredients:
\medskip

\noindent \texttt{(bind ?ingredients\break (pregunta-llista "Hi ha algun ingredient que no desitgi
incloure al menu"))
}





\section{Funciones útiles}


\subsection{Obtener una respuesta de un conjunto predefinido de respuestas posibles}

\begin{verbatim}
(deffunction   pregunta  (?pregunta  $?valores-permitidos)
      (progn$
        (?var ?valores-permitidos)
        (lowcase ?var))
      (format t "¿%s? (%s) " ?pregunta (implode$ ?valores-permitidos))
      (bind ?respuesta (read))
      (while (not (member (lowcase ?respuesta) ?valores-permitidos)) do
        (format t "¿%s? (%s) " ?pregunta (implode$ ?valores-permitidos))
        (bind ?respuesta (read))
      )
   ?respuesta
)
\end{verbatim}

Esta función guarda en el parámetro \texttt{respuesta} la respuesta elegida. La función es muy simple:
\begin{enumerate}
\item Convierte a minúsculas el conjunto de valores permitidos para prevenir errores de comparación.
\item Lee de teclado y guarda la respuesta en la variable \texttt{respuesta}
\item Mientras la respuesta no sea una de las permitidas sigue haciendo la pregunta.
\item Devuelve la respuesta correcta.
\end{enumerate}


\subsection{Obtener un valor numérico comprendido en un rango}

\begin{verbatim}
(deffunction   pregunta-numerica (?pregunta ?rangini ?rangfi)
 (format t "¿%s? [%d, %d] " ?pregunta ?rangini ?rangfi)
 (bind ?respuesta (read))
 (while (not(and(> ?respuesta ?rangini)(< ?respuesta ?rangfi))) do
        (format t "¿%s? [%d, %d] " ?pregunta ?rangini ?rangfi)
        (bind ?respuesta (read))
 )
 ?respuesta
) \end{verbatim}

Esta función guarda en el parámetro \texttt{respuesta} el valor elegido. La función es muy simple:

\begin{enumerate}
 \item Lee de teclado y guarda la respuesta en la variable \texttt{respuesta}
\item Mientras el valor no este contenido dentro del rango deseado sigue haciendo la pregunta.
\item Devuelve la respuesta correcta.
\end{enumerate}


\subsection{Realizar una pregunta general}


\begin{verbatim}
(deffunction   pregunta-general  (?pregunta)
  (format t "¿%s?" ?pregunta)
  (bind ?respuesta (read))
  ?respuesta
)\end{verbatim}

Realiza una pregunta y almacena la respuesta en \texttt{respuesta}

\subsection{¿Cómo se realiza una pregunta binaria?}


\begin{verbatim}
(deffunction si-o-no-p (?pregunta)
    (bind ?respuesta (pregunta ?pregunta si no s n))
    (if (or (eq (lowcase ?respuesta) si) (eq (lowcase ?respuesta) s))
        then TRUE
        else FALSE
    )
) \end{verbatim}

Devuelve cierto si se escribe \texttt{s} o \texttt{si} y falso en caso contrario.

\subsection{Encuentra la instancia con valor mínimo para un slot }

\begin{itemize}
\item  El primer parámetro es la lista de instancia.
\item El segundo parámetro es el método con el que se accede al slot.
\item El tercer parámetro es el valor con que se inicializa la instancia.
\end{itemize}


Devuelve FALSE si no encuentra ninguno o si la lista está vacía.


\begin{verbatim}
(deffunction minimum-slot (?li ?sl ?init)
 (bind ?encontrado FALSE)
 (if (neq ?li FALSE) then
 (bind ?li (create$ ?li))

  (if (> (length ?li) 0) then

   (bind ?min ?init)
   (loop-for-count (?i 1 (length ?li))

    (bind ?v (send (nth$ ?i ?li) ?sl))

    (if (< ?v ?min) then

     (bind ?encontrado TRUE)
     (bind ?min ?v)
     (bind ?ins (nth$ ?i ?li))

    )
   )
  )
 )
 (if (eq ?encontrado FALSE) then
  (bind ?ins FALSE)
 )
 (return ?ins)
)
\end{verbatim}

\subsection{Elimina de la lista de instancias aquellas que por el multislot sl no contengan valor const}

\begin{itemize}
 \item El primer parámetro es la lista de instancia.
\item  El segundo parámetro es el método con el que se accede al slot.
\item  El tercer parámetro es el valor con que se inicializa la instancia.
\end{itemize}

Devuelve FALSE si no encuentra ninguno o si la lista esta vacía.


\begin{verbatim}
(deffunction filtrar-multi-por (?li ?sl ?const)

 (bind ?encontrado FALSE)
 (if (neq ?li FALSE) then

  (bind ?li (create$ ?li))

  (if (> (length ?li) 0) then
   (loop-for-count (?i 1 (length ?li))
    (bind $?v (send (nth$ ?i ?li) ?sl))
    (if (member$ ?const $?v) then
     (if (eq ?encontrado FALSE) then
      (bind ?encontrado TRUE)
      (bind ?ins (nth$ ?i ?li))
     else
      (bind ?ins (create$ ?ins (nth$ ?i ?li)))
     )
    )
   )
  )
 )
 (if (eq ?encontrado FALSE) then
  (bind ?ins FALSE)
 )
 (return ?ins)
)
\end{verbatim}

\subsection{Random slot. Devuelve una instancia aleatoria de entre las que hay en la lista li.}

\begin{verbatim}
(deffunction random-slot ( ?li )
 (bind ?li (create$ ?li))
 (bind ?max (length ?li))
 (bind ?r (random 1 ?max))
 (bind ?ins  (nth$ ?r ?li))
 (return ?ins)
)
\end{verbatim}

\subsection{Recorre todos los elementos del slot que recibe por parámetro y los imprime por pantalla}



\begin{verbatim}
(deffunction imprime-todo (?v)
  (if (> (length$ ?v) 0) then
   (loop-for-count (?i 1 (length ?v))
     (send (nth$ ?i ?v) print)
     (printout t crlf)
   )
 )
)\end{verbatim}



\section{Ejecución de un programa CLIPS}

\subsection{¿Cómo cargamos un programa?}

Para programar en CLIPS utilizaremos ficheros con extensión CLP que contendrán
el conjunto de instrucciones ha ejecutar.
\subsubsection*{Entorno Windows / Mac OS X}
\begin{description}
 \item[Cargar por comandos:] Debemos escribir   \texttt{(load
"PATH/nombrefichero.clp")}
\item [Cargar por entorno grafico:] Debemos ir al menú -$>$ load -$>$
seleccionar el
fichero.
 \end{description}


\subsubsection*{Entorno Linux}
\begin{description}
 \item[Cargar por comandos:] Debemos escribir  (load ``PATH/nombrefichero.clp'')
 \end{description}


\subsection{¿Cómo probar tu código en CLIPS?}

Tienes que abrir
la aplicación CLIPS y escribir (clear) en el Dialog Window. Posteriormente,
necesitas cargar los ficheros clips. Si tienes la ontología y las reglas por
separado tendras que cargar primero el fichero con la ontología y despues el de
las reglas. Esto lo puedes hacer desde File->Load y seleccionando el fichero
\texttt{.clp} en cuestión. A continuación debes escribir (reset) en el Dialog
Window y ahora CLIPS ya estará preparado para ejecutar tu código. En concreto,
lo hará cuando escribas \texttt{(run)}.




\subsection{¿Qué es necesario hacer entre ejecución y ejecución?}

Una vez has acabado una ejecución de tu código, si por el motivo que sea quieres
realizar otra, es imprescindible que escribas (reset) en el Dialog Window ya que
así borras todas las reglas activadas y los hechos introducidos en la anterior
ejecución. A continuación, podrías empezar la ejecución con el comando (run).
Si al finalizar una ejecución, introduces algún cambio en el código y quieres
probarlo, debes seguir lo explicado en la pregunta ¿Cómo probar tu código en
CLIPS? pero sin tener que abrir el CLIPS de nuevo.

\subsection{¿Cómo parar una ejecución?}

Para detener la activación de reglas se usa el comando \texttt{(halt)}. La agenda permanece intacta, y la ejecución puede reanudarse con el comando \texttt{(run)}.
No devuelve ningún valor.

\subsection{¿Como vuelvo al estado inicial y qué contendrá éste?}

Con la función \texttt{reset}. Éste contendrá todos los hechos declarados con
\texttt{deffacts}, las instancias de definstances y las reglas (empezando desde
cero obviamente).

\chapter{Consejos prácticos}

\section{Tinc el disseny de la pràctica fet, però a l'hora d'implementar tot
això no sé
ni per on començar! Algun consell?}

Bé, tothom té formes de treballar diferents, però un bon sistema pot ser el
següent:

Comença amb una ontologia molt reduïda, que tingui un parell de classes i molt
poques instàncies a cada classe (per poder provar coses).
Després fes funcions i/o regles senzilles amb CLIPS que et permetin obtenir
informació de l'ontologia que has creat. Pots començar amb regles que et
retornin totes les instàncies d'una determinada classe. Segurament això al
principi també et pot ser confós, aquí tens un exemple molt bàsic:

\begin{verbatim}
(defrule retorna_instancies
   (not retorna_instancies ok)
    =>
   (bind ?llista_instancies (find-all-instances ((?instancia Nom_Classe)) TRUE)
   (assert retorna_instancies ok)
)
\end{verbatim}

Un cop tinguis una regla que funciona i que saps com funciona, es tracta
d'anar-hi afegint coses a poc a poc (tant a les regles com a l'ontologia). Com
ara canviant el \texttt{TRUE} de l'exemple anterior per alguna condició de
l'estil

\begin{verbatim}
  (eq ?instancia:nom nom_de_la_instancia_que_vull)
\end{verbatim}


\section{¿Como estructuro una practica de CLIPS?}

A continuación se presenta una propuesta de estructura, para facilitar el comienzo de la misma.
El diseño esta sacado de la práctica  MIKEO cedida por EVA Pallarés.

\begin{enumerate}
 \item Definición de las clases

Aquí deberíamos hacer un \textit{ cortar y pegar} de todo el contenido de fichero \texttt{.pont}

\item  Instancias

Aquí deberíamos hacer un \textit{ cortar y pegar} de todo el contenido de fichero \texttt{.pins}

\item  Exportación del MAIN

\texttt{(defmodule MAIN (export ?ALL))}

\item Templates

Incluimos posibles templeates que tengamos que utilizar.

\item  Mensajes

En esta parte incluiremos la comunicación (envió de mensajes) con las clases. Como habitualmente, en la práctica de CLIPS, la utilización de envío de mensajes  se suele utilizar para imprimir  el contenido de una clase, podríamos decir que aquí incluiremos el  código de impresión de clases.

\item  Funciones

 Aquí incluiremos todas las funciones que vayamos a utilizar.

\item  Reglas

 La parte de reglas, como hemos comentado anteriormente estarán agrupadas en módulos.
 La organización de los módulos depende mucho del programador y el problema a resolver.
 De todas formas, existen algunos módulos que se suelen repetir como:

\begin{enumerate}
 \item Módulos de preguntas.

 Será totalmente necesario obtener información sobre las preferencias y restricciones del usuario.

\item Módulo de selección

 Suele ser habitual hacer selección de instancias que cumplan las restricciones impuestas por el usuario.

\item Módulo de construcción

 Será necesario que nuestro SBC construya una solución a nuestro problema.

\item Módulo de impresión de resultados

 Necesitaremos un módulo final para imprimir la solución encontrada.
\end{enumerate}

\end{enumerate}


\section{Com crear un flux de preguntes?}


En la majoria de sistemes experts hi ha una primera fase de recopilació d'informació.

Aquesta recopilació es pot fer a través de preguntes a l'usuari. Aquestes preguntes poden tenir dependències entre elles: per exemple, si un client ens diu que té telèfon mòbil, procedirem a preguntar-li el número d'aquest mòbil, però si ens diu que no, no li preguntarem el número. Així, el fet que el client tingui mòbil és un prerequisit per preguntar-li quin és el número de telèfon del seu mòbil.

Per això usem el sistema de regles que ens proporciona CLIPS i introduirem aquest prerequisit a la part esquerra de la regla.

\begin{verbatim}
(defrule preguntar-numero-mobil
 (mobil si)
 =>
 (printout t "Quin és el teu número de mòbil?")
 (bind ?numero-mobil (read))
 (assert numero-mobil ?numero-mobil)
)
\end{verbatim}

D'aquesta manera, la regla \texttt{preguntar-numero-mobil} només s'activarà
si l'usuari ha contestat que sí a la pregunta ``tens mòbil?''.


\subsection{Com puc ordenar aquest flux de preguntes?}


Per altra banda, ens pot interessar fer que les preguntes que fem a l'usuari tinguin un cert ordre. Per exemple, ens pot interessar preguntar-li a l'usuari primer el seu nom, i posteriorment preguntar-li si té telèfon mòbil. En aquest cas la primera pregunta no és un prerequisit per preguntar la segona, però és de sentit comú que tinguin aquest ordre. Per traduir això a clips podem fer:

\begin{verbatim}
(defrule preguntar-mobil
 (nom ?nom-usuari)
 =>
 (
  if (yes-or-no-p "Tens telèfon mòbil?")
  then (assert (mobil si))
  else (assert (mobil no))
 )
)
\end{verbatim}

D'aquesta manera la pregunta sobre el mòbil només es dispararà quan l'usuari hagi contestat a la pregunta del seu nom.


\subsection{I si vull saltar-me una pregunta?}


En alguns casos ens podem trobar amb la situació de tenir una pregunta ja resolta implícitament en la resposta d'alguna pregunta prèvia. Per exemple, suposem que volem preguntar-li a una persona si vol prendre alguna beguda alcohòlica, però prèviament li hem preguntat la edat en aquesta persona. Podríem fer-ho de dues maneres.
\begin{enumerate}
 \item Com fins ara, amb:

\begin{verbatim}
(defrule preguntar-alcohol
 (edat major-edat)
 =>
 (
  if (yes-or-no-p "Vols prendre alguna beguda alcoholica?")
  then (assert (alcohol si))
  else (assert (alcohol no))
 )
)
\end{verbatim}
Aquesta solució funcionaria, però imaginem que també hem preguntat a l'usuari quina és la seva religió. Si l'usuari ha contestat ``religió musulmana'', aleshores tampoc li haurem de preguntar si vol prendre alcohol. Haurem d'afegir a la part esquerra de la regla una sentencia com:

 \texttt{(not (religio musulmana))}

com a prerequisit, i haurem de fer el mateix amb cadascun dels fets o motius que impliquin que la persona no pot beure alcohol.

\item Una altra manera és ``enganyar'' al sistema i fer-li creure que l'usuari ja ha respost la pregunta sobre l'alcohol actuant en el moment de preguntar per la religió. Així:


\begin{verbatim}
(defrule preguntar-religio
 =>
 (bind ?religio 
  (ask-question "Quina religió practiques?" catòlica musulmana budista cap))
 (if (eq ?religio "musulmana")
  then (assert (alcohol no)) (assert (porc no)))
)\end{verbatim}

I després:

\begin{verbatim}
(defrule preguntar-alcohol
 (not (alcohol ?si_o_no)
 =>
 ...
)\end{verbatim}

I ja posats també:

\begin{verbatim}
(defrule preguntar-porc
 (not (porc ?si_o_no))
 =>
 ...
)\end{verbatim}

D'aquesta manera aconseguim que el sistema no pregunti a l'usuari si vol prendre alcohol o si vol menjar porc, perquè en el moment de preguntar-li la religió hem tingut en compte aquests valors. A més, hem trobat una manera de implementar un flux de preguntes en el qual, alhora d'obtenir les respostes, no hem de modificar regles ``futures'' (dins del flux d'execució de preguntes).

\end{enumerate}

\subsection{Com inicialitzar el flux del programa?}


Per inicialitzar el flux d'execució tenim varies possibilitats.

Algunes d'elles són:
\begin{itemize}
\item Definir un fet per defecte (deffact) el qual faci saltar una regla inicial
per defecte (que podríem definir amb un salience alt).

Per exemple,

\begin{verbatim}
(deffacts tipus-usuari
  (us desconegut)
)
\end{verbatim}
Que faria saltar la regla inicial:

\begin{verbatim}
(defrule inici
(declare (salience 10))
?us <- (us desconegut)
=>
(printout t "Benvingut!" crlf)
....
)\end{verbatim}

\item Una regla inicial podria preguntar per si no existeix un fet que acabarà inicialitzant.

Per exemple,

\begin{verbatim}
(defrule inici
 (not (flor ?tipus))
=>
(printout t "Benvingut" crlf)
...
(assert (flor rosa))
)\end{verbatim}
\end{itemize}


\section{Uso de la función modify para ir guardando resultados preferidos}

Para empezar hemos de tener una plantilla que, en el caso de un sistema para escoger platos, sea donde coloquemos los platos que se van ajustando a nuestra. Esta seria su estructura:

\begin{verbatim}
(deftemplate platos-apropiados
   (slot estado)
   (multislot lista-platos1)
   (multislot lista-platos2)
   (multislot lista-postres)
)\end{verbatim}

Entonces cuando vayamos obteniendo resultados para ir guardandalos en los diferentes multislots, tendremos que llamar a la instancia de dicha plantilla desde los activadores de las reglas, usando como guía el slot estado.


	\texttt{?paprop <- (platos-apropiados (estado empezado))}

En este caso recuperariamos la instancia de \texttt{platos-apropiados} que ha sido inicializada en otra regla, pero mantendriamos la misma con los resultados ya guardados hasta el momento.
Si en esta regla quisieramos insertar datos en otro multslot de dicha instancia (por ejemplo \texttt{lista-platos2}) tendriamos el siguiente código:

	\texttt{(modify ?paprop (estado empezado)(lista-platos2 \$?lista2))}

Donde \texttt{lista2} seria el resultado de hacer un \texttt{find-all-instances} por ejemplo.

\section{Creación de la plantilla de recomendación}

Una vez aplicadas todas las reglas necesarias y manipulado todo el conocimiento que hayamos tenido que usar en el problema, deberemos mostrar los resultados al usuario. Para ello, si partimos de que hemos tenido que construir un resultado a partir de ciertas preferencias o restricciones, lo más adecuado es usar una plantilla para poner el resultado y tenerlo estructurado. En este caso, lo que se debe hacer es partir de una plantilla vacia, la cual se irá rellenando conforme calculemos los resultados. La plantilla será un deftemplate con los atributos que va a tener el resultado final y deberá estar en un ámbito visible para todos los módulos, para que así la puedan ir modificando y completando.

Ejemplo de plantilla de recomendación para menús de restaurante:

\begin{verbatim}
(deftemplate recomendacion "Recomendacion resultante del sistema experto"
  (slot evento)
  (multislot menus)
  (slot final?)
)\end{verbatim}

Donde el slot evento guardaria una instancia de la clase Evento que contendria las propiedades de la comida (número invitados, temporada, ...), el multislot menus tendria las instancias de los menús finales para proponer y el slot final? seria una guia para, una vez obtenidos los resultados, activar la regla para mostrar los resultados por pantalla

\chapter{Errores frecuentes}

\section{Quan obro un fitxer en CLIPS em dona un error!}


L'editor de text de l'entorn gràfic de CLIPS no accepta fitxers més grans de
65KB. Aquesta quantitat de bytes pot ser àmpliament superada quan introduïm una
gran quantitat d'instàncies a la base de coneixement mitjançant protégé i la
exportem a format CLIPS.

Per saltar aquest problema només hi ha una solució: carregar el fitxer
directament per línia de comandes, sense usar l'editor de text de CLIPS, amb la
comanda \texttt{(load <NOM\_FITXER>)}.

Per exemple:

\begin{verbatim}
(load fitxer.clp)
\end{verbatim} 
Per a continuació, fer:

\begin{verbatim}
(reset)
(run)
\end{verbatim} 


\section{Codificació de caràcters a CLIPS}


CLIPS dona força problemes amb caràcters estranys com ñ, accents, dièresis,
etc.

En principi no accepta Unicode ni \texttt{ISO-8859-1}, així que recomanem no fer
servir caràcters com els mencionats per tal de no tenir problemes. A més,
protégé exporta amb codificació \texttt{ISO-8859-15}. La majoria d'editors de
linux usen per defecte codificació \texttt{UTF-8}. Això és un problema, perquè
alhora d'editar un document podeu perdre alguns caràcters si no configureu la
codificació del vostre editor a I\texttt{SO-8859-15} i això provocarà que CLIPS
no reconegui el fitxer com a vàlid. Un editor de linux que permet canviar la
codificació de caràcters usada en un fitxer és \texttt{kwrite} (cal
configurar-ho abans de començar a modificar el fitxer).

Si al carregar un fitxer tenim problemes i no ho sabem identificar, és útil
comprovar si pot haver-hi algun caràcter que estigui creant aquests problemes.


\section{Què significa l'error OBJRTBLD5?}

A l'apèndix G de la ``CLIPS Basic Programming Guide'' trobaràs el significat de tots els errors que dóna CLIPS.





\section{Antes compilaba correctamente y ahora da warnings.}

\texttt{[CSTRCPSR1] WARNING: Redefining defrule: imprimir +j+j.}

Si aparecen warnings como este a la hora de compilar en todas las funciones, reglas, etc, que se han
definido en el código, es posible que no se haya hecho un \texttt{clear} antes de compilar
nuevamente.
Para ello usar la opción del menu  \textit{Execution} $\rightarrow$ \textit{Clear Clips}, o bien, en
la ventana de entrada de CLIPS escribir  \texttt{(clear)}.
Luego volvemos a cargar el fichero.

Este problema es debido a que los módulos no pueden ser ni redefinidos ni borrados una vez que se definen (con la excepción del módulo MAIN que puede ser redefinido una vez). La única forma de eliminar un módulo es con el comando clear.


\section{No puedo editar mi fichero en clips.}

Esto es debido a que el .clp ha llegado a su máxima extensión. Para solucionar el problema, debemos abrirlo con un editor de texto externo y proceder como siempre, es decir:

\begin{verbatim}
Execution -> Clear Clips
Execution -> Load (seguiremos cargando el .clp/.txt que 
                   hemos modificado y guardado previamente en el editor de texto).
Execution -> Reset
Execution -> Run
\end{verbatim}

\section{Redefining}

Este warning es debido en el mayor número de casos, a que existen dos o más reglas, funciones, ... que tienen el mismo nombre. Para solucionarlo, obviamente, cambiar el nombre de cada una de manera que no compartan nombres.

\section{Problemas al consultar las instancias relacionadas con otras}

Por alguna razón desconocida CLIPS solo busca instancias en el modulo actual y no en todos los importados.
La solución mas sencilla es añadir a todas las instancias de la ontología el cualificador del modulo principal. Si se substituye en el fichero de las instancias la cadena ``['' por ``[MAIN::'' estará todo solucionado.

Por ejemplo:
\medskip

\texttt{([pracIA\_Instance\_30001] of  Bebida $\rightarrow$ ([MAIN::pracIA\_Instance\_30001] of  Bebida}


\section{Unable to finde class X cuando definimos instancias}


\begin{verbatim}
Defining definstances: instancias
[PRNTUTIL1] Unable to find class Plato.

ERROR:
(definstances MAIN::instancias
 ([pracIA_Instance_1] of Plato\end{verbatim}

Si nos aparece algo parecido a esto cuando compilamos nuestro programa significa que no encuentra la
clase a la que pertenece la instancia. Es posible que hayamos definido primero las instancias y
luego las clases. Para corregirlo, seguir la estructura comentada en el fichero de CLIPS: ontología
+ instancias + código.

\section{Expected the beginning of a construct (cuando definimos instancias).}


Si nos aparece este error justo donde definimos las instancias, es posible que sea porque no hayamos seguido la correcta estructura para añadir instancias en nuestro código:
\texttt{(definstances cualquiernombre INSTANCIAS )}.


\section{Compila pero no compara bien dos elementos}

Posiblemente se trata de que estemos realizando la comparación de dos cadenas de caracteres con el operador eq. Existe una funcion especifica para comparar dos strings: str-compare explicada en el apartado de funciones.


\section{Expected the beginning of a constructor}


Aquest error sol ser molt freqüent i es pot donar per diversos motius.

\begin{enumerate}
 \item El primer i més freqüent és perquè hem posat un parèntesis tancat ``)'' de més. Surt quan, per exemple, tenim:

\texttt{(assert (processador AMD) ) ) ; <-- l'últim parèntesis sobra}

Haurem de repassar quin ha estat el codi que hem retocat que ens ha incorporat aquest error i trobar el parèntesis que sobra.
\item El segon motiu pel qual també es pot donar aquest error és perquè, per exemple, no hem encapsulat el codi de les instàncies generades automàticament mitjançant protégé dins la clau:

\begin{verbatim}
(definstances nominstancies
 <instàncies>
)
\end{verbatim}
En definitiva, el que aquest error ens està indicant és que CLIPS espera la construcció d'una regla/funció/acció/etc. i en comptes d'això es troba amb qualsevol altra cosa: un parèntesis tancat, una instància, etc.
\end{enumerate}



\section{Missing function declaration for defrule/deffunction/...}


Aquest error acostuma a donar-se quan ens hem descuidat de posar el parèntesis que tanca la definició d'una regla/funció/etc. i aquesta es ``solapa'' amb la següent regla/funció/etc.
Per exemple:

\begin{verbatim}
(defrule pregunta-A
 (precondicio pre)
 =>
 (assert (accio realitzada))
     ; <--- aquí falta un parèntesis que tanqui la regla

(deffunction funcio-B
 ...
)\end{verbatim}


\section{Check appropiate syntax for if/switch/loop-for-count/...}


Aquest error ens apareixerà quan no hem respectat la sintaxi d'alguna de les estructures de control de flux com if, switch, loop-for-count, etc. Pot deure's a qualsevol motiu (falta de parèntesis, expressions incorrectes), però sempre dins de la estructura de control que ens indica CLIPS.

Per exemple:

\begin{verbatim}
(switch (?resposta) ; <---- sobren els parèntesis que engloben la ?resposta!!!
   (case 1  then (assert (fet primer)) )
   ...
)
\end{verbatim}


\section{Problemas con paréntesis}

Se trata de uno de los errores más típicos a la hora de compilar y a su vez más difíciles de depurar. El problema se encuentra en que no hemos cerrado todos los paréntesis que se han abierto.
Una forma rápida para comprobar si la forma de colocar los paréntesis es la correcta, seria sumar 1 cuando se abre un paréntesis y restar 1 cuando se cierra, de manera que si al final su cómputo es 0, es correcto. Por ejemplo:


\begin{verbatim}
        (  (  2  +  3 )  *  ( 4  /  ( 1 + 1 ) ) )
      0 1  2          1     2       3         2 1 0
\end{verbatim}
Es muy recomendable y facilita mucho la tarea de encontrar bugs, ponerlos tabulados con comentario en el cierre

\begin{verbatim}
(while
...
) ;endwhile
\end{verbatim}

\chapter{Referencias}

\section{On puc trobar informació sobre el llenguatge CLIPS?}

Llegeix-te la ``CLIPS User Guide''. És un document que explica amb un llenguatge
senzill tot el que es pot fer amb CLIPS, començant amb coses fàcils i es va
complicant mica en mica. Veuràs que és una mica llarga, però és prou
entretinguda de llegir. La pots trobar a l'adreça següent:

\href{http://www.ghg.net/clips/download/documentation/usrguide.pdf}{
\texttt{http://www.ghg.net/clips/download/documentation/usrguide.pdf}}.
No obstant, a la ``CLIPS User Guide'' només hi ha els conceptes més importants.
Si no trobes alguna cosa, consulta la ``CLIPS Basic Programming Guide'', que
trobaràs aquí:

\href{http://www.ghg.net/clips/download/documentation/bpg.pdf}{\texttt{
http://www.ghg.net/clips/download/documentation/bpg.pdf}}.

\section{Otras referencias}

\begin{itemize}
\item
\href{
http://www.lsi.upc.edu/~bejar/ia/material/laboratorio/clips/clips4.pdf}{{
\tt
http://www.lsi.upc.edu/\~{}bejar/ia/material/laboratorio/clips/clips4.pdf}}
\item
\href{http://www.gsi.dit.upm.es/~cif/cursos/ssii/clipshtml/clips-index}{{
\tt
http://www.gsi.dit.upm.es/\~{}cif/cursos/ssii/clipshtml/clips-index}}
\item \href{http://www.geocities.com/aitorsjs/html/clips.pdf}{{\tt
http://www.geocities.com/aitorsjs/html/clips.pdf}}
\item \href{http://scalab.uc3m.es/~docweb/ia/practicas/clips.pdf}{{\tt
http://scalab.uc3m.es/\~{}docweb/ia/practicas/clips.pdf}}
\item \href{http://vmbenet.iespana.es/IMG/pdf/Fpract3.pdf}{{\tt
http://vmbenet.iespana.es/IMG/pdf/Fpract3.pdf}}
\item \href{http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}{{\tt
http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}}
\item
\href{http://www.lsi.upc.es/~bejar/ia/material/laboratorio/clips/bpg.pdf}
{{\tt
http://www.lsi.upc.es/\~{}bejar/ia/material/laboratorio/clips/bpg.pdf}}
\item
\href{
http://www.lsi.upc.es/~bejar/ia/material/laboratorio/clips/usrguide.pdf}{
{\tt
http://www.lsi.upc.es/\~{}bejar/ia/material/laboratorio/clips/usrguide.pdf}}
\item Manual molt bo (i extens) de CLIPS, escrit per Aitor San Juan Sánchez
(castellà)

\href{http://www.geocities.com/aitorsjs/html/clips.pdf}{{\tt
http://www.geocities.com/aitorsjs/html/clips.pdf}}

\item Basic programming guide (anglès):

\href{http://www.csie.ntu.edu.tw/~sylee/courses/clips/bpg/node1.html}{{
\tt http://www.csie.ntu.edu.tw/\~{}sylee/courses/clips/bpg/node1.html}}

\item Basic Programing guide Vol. 1 (anglès):

\href{http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}{{\tt
http://www.gsi.dit.upm.es/docs/clipsdocs/clipshtml/vol1.html}}

\item Manual resumit de clips (castellà):

\href{http://scalab.uc3m.es/~docweb/ia/manual/manual/manual.html}{{\tt
http://scalab.uc3m.es/\~{}docweb/ia/manual/manual/manual.html}}

\item Manejo Básico de clips (castellà):

\href{http://trevinca.ei.uvigo.es/~jgarcia/SIEX/Clips.html}{{\tt
http://trevinca.ei.uvigo.es/\~{}jgarcia/SIEX/Clips.html}}

\item 6 Tutorials curts de clips (anglès):

\href{http://iweb.tntech.edu/bhuguenard/ds6530/ClipsTutorial/tableOfContents.htm}
{{\tt
http://iweb.tntech.edu/bhuguenard/ds6530/ClipsTutorial/tableOfContents.htm}}

\item Un fòrum (com el fòrum de IA de la FIB) d'un altre universitat espanyola
(castellà):

\href{https://apps.lab.inf.uc3m.es/foro/viewforum.php?f=59}{{\tt
https://apps.lab.inf.uc3m.es/foro/viewforum.php?f=59}}
\item Problemes resolts sobre CLIPS (anglès):

\href{
http://pesona.mmu.edu.my/~ytbau/tes3211/expert_systems_problems_and_sol.html}{{\tt
http://pesona.mmu.edu.my/\~{}ytbau/tes3211/expert\_systems\_problems\_and\_sol.html}}

\end{itemize}
\end{document}
